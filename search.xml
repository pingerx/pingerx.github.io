<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows 10永久激活</title>
      <link href="/2020/01/06/windows-yong-jiu-ji-huo/"/>
      <url>/2020/01/06/windows-yong-jiu-ji-huo/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows-10永久激活"><a href="#Windows-10永久激活" class="headerlink" title="Windows 10永久激活"></a>Windows 10永久激活</h3><p>现在市面上大致有两种主流激活方法，一种是通过激活码来激活，另外一种是通过激活工具来激活。但是激活工具有个弊端就是激活时间只有180天。<br>偶然看到另一个超级简单的永久激活方法，顺带记录下来。</p><p>在命令行中依次输入：</p><ol><li><code>slmgr.vbs /upk</code>，提示“已成功卸载了产品秘钥”</li><li><code>slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</code>，提示“成功的安装了产品秘钥”</li><li><code>slmgr /skms zh.us.to</code>，提示“密钥管理服务计算机名成功的设置为 zh.us.to”</li><li><code>slmgr /ato</code>，提示“成功的激活了产品”</li></ol><h2 id="秘钥记录"><a href="#秘钥记录" class="headerlink" title="秘钥记录"></a>秘钥记录</h2><h3 id="Windows-10系统"><a href="#Windows-10系统" class="headerlink" title="Windows 10系统"></a>Windows 10系统</h3><ul><li><p>企业版：XGVPP-NMH47-7TTHJ-W3FW7-8HV2C</p></li><li><p>教育版：YNMGQ-8RYV3-4PGQ3-C8XTP-7CFBY</p></li><li><p>专业版N：2B87N-8KFHP-DKV6R-Y2C8J-PKCKT</p></li><li><p>企业版N：WGGHN-J84D6-QYCPR-T7PJ7-X766F</p></li><li><p>教育版N：84NGF-MHBT6-FXBX8-QWJK7-DRR8H</p></li><li><p>企业版S：FWN7H-PF93Q-4GGP8-M8RF3-MDWWW</p></li><li><p>单语言版：BT79Q-G7N6G-PGBYW-4YWX6-6F4BT</p></li><li><p>Windows 10 Core Single Language:JPYNJ-XTFCR-372YJ-YJJ4Q-G83YB</p></li><li><p>Windows 10 Core 中文版 Language Edition:R3BYW-CBNWT-F3JTP-FM942-BTDXY</p></li><li><p>Windows 10 Core :KTNPV-KTRK4-3RRR8-39X6W-W44T3</p></li><li><p>Windows 10 Pro:8N67H-M3CY9-QT7C4-2TR7M-TXYCV</p></li><li><p>Windows 10 Enterprise:CKFK9-QNGF2-D34FM-99QX3-8XC4K</p></li><li><p>Windows 10 Core Single Language :JPYNH-XTFCR-372YJ-YJJ3Q-G83YB</p></li><li><p>Windows 10 Core Chinese Languange Edition:R3BYW-CBNWT-F3JTP-FM942-BTDXY</p></li></ul><h3 id="Windows-10-Pro-win10专业版激活密钥"><a href="#Windows-10-Pro-win10专业版激活密钥" class="headerlink" title="Windows 10 Pro(win10专业版激活密钥)"></a>Windows 10 Pro(win10专业版激活密钥)</h3><ul><li>TPYNC-4J6KF-4B4GP-2HD89-7XMP6</li><li>2BXNW-6CGWX-9BXPV-YJ996-GMT6T</li><li>NRTT2-86GJM-T969G-8BCBH-BDWXG</li><li>XC88X-9N9QX-CDRVP-4XV22-RVV26</li><li>TNM78-FJKXR-P26YV-GP8MB-JK8XG</li><li>TR8NX-K7KPD-YTRW3-XTHKX-KQBP6</li><li>VK7JG-NPHTM-C97JM-9MPGT-3V66T</li><li>NPPR9-FWDCX-D2C8J-H872K-2YT43</li><li>W269N-WFGWX-YVC9B-4J6C9-T83GX</li><li>NYW94-47Q7H-7X9TT-W7TXD-JTYPM</li><li>NJ4MX-VQQ7Q-FP3DB-VDGHX-7XM87</li><li>MH37W-N47XK-V7XM9-C7227-GCQG9</li></ul><h3 id="win10企业版："><a href="#win10企业版：" class="headerlink" title="win10企业版："></a>win10企业版：</h3><ul><li>Windows 10 Enterprise : NPPR9-FWDCX-D2C8J-H872K-2YT43</li><li>Windows 10 Enterprise N: DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4</li><li>Windows 10 Enterprise 2015 LTSB :WNMTR-4C88C-JK8YV-HQ7T2-76DF9</li><li>Windows 10 Enterprise 2015 LTSB N : 2F77B-TNFGY-69QQF-B8YKP-D6</li></ul><h3 id="win10预览版密钥："><a href="#win10预览版密钥：" class="headerlink" title="win10预览版密钥："></a>win10预览版密钥：</h3><ul><li>Win10企业版密钥：PBHCJ-Q2NYD-2PX34-T2TD6-233PK</li><li>Win10专业版密钥：NKJFK-GPHP7-G8C3J-P6JXR-HQRJR</li></ul>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务端常用命令</title>
      <link href="/2020/01/05/linux-fu-wu-duan-chang-yong-ming-ling/"/>
      <url>/2020/01/05/linux-fu-wu-duan-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><ul><li>进入目录：cd /dir</li><li>退出目录：cd ..</li></ul><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><ul><li>查看当前目录文件和目录名：ls</li><li>查看当前目录文件，包含文件的属性与权限数据：ll</li></ul><h3 id="rz命令"><a href="#rz命令" class="headerlink" title="rz命令"></a>rz命令</h3><ul><li>使用rz命令，在具体的目录下命令行输入<code>sudo rz</code>命令，选择文件即可上传到该目录</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Linux </tag>
            
            <tag> 2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菲国美食打卡</title>
      <link href="/2019/12/28/fei-guo-mei-shi-da-qia/"/>
      <url>/2019/12/28/fei-guo-mei-shi-da-qia/</url>
      
        <content type="html"><![CDATA[<h3 id="China-Blue"><a href="#China-Blue" class="headerlink" title="China Blue"></a>China Blue</h3><p>位于Passy Conrad 酒店三楼。海景餐厅。去过两次，第一次和Emma的闺蜜团们，我请的客，喝了一瓶红酒，想把她男朋友丢到海里去。第二次和本地的华裔女孩Astrid，人很温柔，和她一起吃饭非常舒服。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 美食 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅游计划</title>
      <link href="/2019/12/19/lu-you-ji-hua/"/>
      <url>/2019/12/19/lu-you-ji-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="日本"><a href="#日本" class="headerlink" title="日本"></a>日本</h3><ul><li><p>攻略地址：<a href="https://www.tsunagujapan.com/zh-hans/" target="_blank" rel="noopener">https://www.tsunagujapan.com/zh-hans/</a></p></li><li><p>项目：春天看樱花</p></li></ul><h3 id="菲律宾"><a href="#菲律宾" class="headerlink" title="菲律宾"></a>菲律宾</h3><ul><li>白沙滩</li><li>薄荷岛</li><li>长滩岛</li></ul><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><ul><li>跳伞</li><li>深潜</li><li>山地车</li><li>直升机环岛游</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>东南亚国家特产</title>
      <link href="/2019/12/19/dong-nan-ya-guo-jia-te-chan/"/>
      <url>/2019/12/19/dong-nan-ya-guo-jia-te-chan/</url>
      
        <content type="html"><![CDATA[<p>唯有美食与爱不可辜负。希望有朝一日，能与爱人尝遍各国特产，感受各国异域风情。</p><h3 id="日本"><a href="#日本" class="headerlink" title="日本"></a>日本</h3><ul><li>北海道白色恋人（一个日本的朋友经常带过来吃，特别好吃的千克力饼干）</li><li>东京香蕉蛋糕</li><li>长崎蜂蜜蛋糕</li></ul><h3 id="菲律宾"><a href="#菲律宾" class="headerlink" title="菲律宾"></a>菲律宾</h3><ul><li>芒果干（比较出名的品牌是：Cebu(宿务)和7D）</li><li>香蕉片（品牌：Jovy’ s）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 特产 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗和远方</title>
      <link href="/2019/12/17/shi-he-yuan-fang/"/>
      <url>/2019/12/17/shi-he-yuan-fang/</url>
      
        <content type="html"><![CDATA[<h1 id="生活不仅有眼前的苟且，还有诗和远方。"><a href="#生活不仅有眼前的苟且，还有诗和远方。" class="headerlink" title="生活不仅有眼前的苟且，还有诗和远方。"></a>生活不仅有眼前的苟且，还有诗和远方。</h1><a id="more"></a><h3 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h3><ul><li>谈一对象</li><li>南昌买房</li><li>年底攒够50万</li><li>一个月至少一篇博客</li><li>英语口语练习</li><li>菲驾照，学会开车</li><li>来一次跳伞</li></ul><h3 id="2024年前"><a href="#2024年前" class="headerlink" title="2024年前"></a>2024年前</h3><ul><li>春天去日本看樱花</li><li>博士硕士双证，预计人民币30万</li></ul><h3 id="有生之前"><a href="#有生之前" class="headerlink" title="有生之前"></a>有生之前</h3><ul><li>养一只蓝猫和萨摩耶，期待猫狗大战</li><li>西藏自驾游</li><li>买一套外星人顶配电脑（玩LOL）</li><li>买一套PS4玩游戏</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不成疯便成魔</title>
      <link href="/2019/12/13/bu-cheng-feng-bian-cheng-mo/"/>
      <url>/2019/12/13/bu-cheng-feng-bian-cheng-mo/</url>
      
        <content type="html"><![CDATA[<h3 id="动感音乐"><a href="#动感音乐" class="headerlink" title="动感音乐"></a>动感音乐</h3><ul><li>无期-石白其</li><li>中毒-光贼</li><li>桥下-谢春花</li><li>神秘嘉宾，别让我走远-林宥嘉</li><li>有可能的夜晚-颜人中</li></ul><h3 id="KTV必点歌曲"><a href="#KTV必点歌曲" class="headerlink" title="KTV必点歌曲"></a>KTV必点歌曲</h3><ul><li>慢慢-张学友</li><li>约定-陈奕迅</li><li>孤独患者-陈奕迅</li><li>冷雨夜-Bybond</li><li>意外-薛之谦</li><li>绅士-薛之谦</li><li>空白格-杨宗纬</li><li>唯一-王力宏</li><li>你最珍贵-张学友</li><li>等不到得爱-樊凡</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> 叙事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在星巴克愉快的使用英文点餐</title>
      <link href="/2019/03/04/ru-he-zai-xing-ba-ke-yu-kuai-de-shi-yong-ying-wen-dian-can/"/>
      <url>/2019/03/04/ru-he-zai-xing-ba-ke-yu-kuai-de-shi-yong-ying-wen-dian-can/</url>
      
        <content type="html"><![CDATA[<p>有的时候衡量一个人英语口语好不好，只需要看这个人能不能在星巴克优雅的点一杯咖啡。在星巴克来来回回也点了上百次了，从第一次不知道怎么选和说，到现在闭着眼睛都能背菜单，中间也就差个上百次～</p><p><img src="https://i.loli.net/2019/12/17/OXIbZUleY6wKGgh.jpg" alt></p><p>在说星巴克点咖啡之前，我们先来简单介绍一下星巴克。星巴克英文名叫Starbucks，发源地与总部位于美国华盛顿州西雅图，是一家全球最大的连锁咖啡店。实际上星巴克是一个自定义饮品的休闲区，只要你不扰乱秩序，你在里面看书、蹭网、聊天、休息等等都OK，至于你点没点饮料，坐多久，是没人会管的。</p><p>同时，在点餐之前，我们要先了解一下星巴克咖啡的常识。</p><ul><li><p>杯型。星巴克的杯子有三种型号，Tall为中杯，Grande为大杯，Venti为超大杯。男生一般选Grande就够了，女生一般选Tall或者Grande。当然如果你要坐下来慢慢喝，你也可以点Venti杯型，既划算，又可以喝很久。<br><img src="https://i.loli.net/2019/12/17/LlKEVZbWpn9yIXa.jpg" alt="杯型"></p></li><li><p>温度。热饮：<code>Hot Drink</code>，含冰冷饮：<code>Iced Drink</code>，去冰：<code>No Ice</code>，少冰 ：<code>Easy On Ice</code>。比如我要点一杯热牛奶，就可以说 <code>I want a cup of hot milk</code> 或者直接 <code>hot milk</code> 都是可以的。</p></li><li><p>糖浆。星巴克所有甜的饮品都是放糖浆的。一般有榛果糖浆：Hazelnut Syrup，香草糖浆：Vanilla Syrup，焦糖糖浆：Caramel Syrup。个人点香草的比较多，非常符合我的口味。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> 叙事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米8 lite手机刷机体验</title>
      <link href="/2019/03/02/xiao-mi-8-lite-shou-ji-shua-ji-ti-yan/"/>
      <url>/2019/03/02/xiao-mi-8-lite-shou-ji-shua-ji-ti-yan/</url>
      
        <content type="html"><![CDATA[<p>最近使用小米8手机，发现miui系统还是挺不错的，但是有一个很致命的缺点，就是广告太多了，而且不能安装谷歌服务。<br>miui系统除了有国内的版本，还有全球版。全球版内置了谷歌服务，并且没有广告，使用起来也是爽歪歪。</p><h4 id="所以毫不犹豫，选择刷机。"><a href="#所以毫不犹豫，选择刷机。" class="headerlink" title="所以毫不犹豫，选择刷机。"></a>所以毫不犹豫，选择刷机。</h4><p>在网上找了下刷机的教程，知乎有个专题专门提供全球版刷机解决方案，按照里面的流程刷了一次，直接成功。</p><p><a href="https://www.zhihu.com/question/50231539" target="_blank" rel="noopener">知乎专题</a></p><p>刷机分为两种，一种是将rom包放到手机里，在手机的升级界面选择rom包进行升级刷机。一种是使用线刷工具，将rom包刷进手机。两种方式都是非常的简单。</p><p><a href="http://en.miui.com/a-232.html" target="_blank" rel="noopener">刷机教程</a></p><p>写完了这段文字，手机也刚刷好~ 又可以继续愉快的玩耍了。</p><hr><p>2月6号，突然发现，之前刷的那个国际版本部分页面还是有谷歌的广告，蛋疼。<br>知乎上有个回答是使用欧盟官方分销商ABC Data认可的MIUI系统。<a href="https://xiaomi.eu/community/" target="_blank" rel="noopener">xiaomi.eu</a></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019 </tag>
            
            <tag> 叙事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android使用Jenkins持续集成</title>
      <link href="/2018/07/23/android-shi-yong-jenkins-chi-xu-ji-cheng/"/>
      <url>/2018/07/23/android-shi-yong-jenkins-chi-xu-ji-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>平时迭代开发需要频繁的打包发布到蒲公英上，重复的操作总是令人厌烦。这里简单介绍一下，使用Jenkins自动打包发布到蒲公英上。</p></blockquote><h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><ul><li>下载最新的版本（一个 WAR 文件）。<a href="https://jenkins.io" target="_blank" rel="noopener">官网下载地址</a></li><li>运行 <code>java -jar jenkins.war</code> 注意：Jenkins 需要运行 Java 5以及以上的版本。</li></ul><a id="more"></a><h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><ul><li>第一次启动，复制命令行中的密码，打开浏览器，输入<code>localhost:8080</code>，输入密码，进入主页，创建用户。</li><li>点击 <code>系统管理-&gt;管理插件-&gt;可选插件</code>，可搜索以下插件安装(其他插件按需安装)。<ul><li>git插件(GIT plugin)</li><li>ssh插件(SSH Credentials Plugin)</li><li>Gradle插件(Gradle plugin)</li></ul></li><li>点击 <code>系统管理-&gt;系统设置-&gt;全局属性</code>，添加以下键值对，要和系统环境一样。<ul><li>ANDROID_HOME</li><li>GRADLE_HOME</li><li>JAVA_HOME</li></ul></li></ul><p><img src="http://chuantu.biz/t6/347/1532335531x-1566688556.jpg" alt="全局属性"></p><ul><li>点击 <code>系统管理-&gt;全局工具配置</code>,Git设置为自动安装，Gradle设置为GRADLE_HOME的路径（路径对上就没问题）。</li></ul><p><img src="http://chuantu.biz/t6/347/1532335501x-1566688556.jpg" alt="全局工具配置"></p><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><ul><li><p>点击新建任务，选择构建一个自由风格的软件项目</p></li><li><p>源码管理，配置Git的仓库</p><ul><li>Repository URL：仓库地址</li><li>Credentials：账号密码</li><li>Branch Specifier：构建分支</li></ul></li><li><p>构建触发器</p><ul><li>定时构建：<code>H/60 * * * *</code>表示60分钟检查一次代码，有更新就构建</li></ul></li></ul><p><img src="http://chuantu.biz/t6/347/1532335446x-1566688556.jpg" alt="仓库和触发器"></p><ul><li>构建(主要配置Use Gradle Wrapper)<ul><li>Make gradlew executable，打钩</li><li>Tasks：<code>build</code>或者是具体的任务<code>:app:assembleRelease</code></li><li>Root Build script：<code>${workspace}</code></li><li>Build File：<code>${workspace}/a8sport/build.gradle</code></li></ul></li></ul><p><img src="http://chuantu.biz/t6/347/1532335583x-1566688556.jpg" alt="构建"></p><h3 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h3><ul><li>点击立即构建，就可以主动构建任务，第一次会从Git服务器拉取代码，可能会有一些问题会构建失败，前几次失败了再构建就好，如果一直失败可能就是配置有问题，看一下控制台输出。</li><li>构建输出目录，点击<code>系统管理-&gt;系统设置</code>可以查看Jenkins的根目录，在根目录下的workspace下有构建的任务，如<code>app/build/outputs/apk/beta/release</code></li></ul><h3 id="发布到蒲公英"><a href="#发布到蒲公英" class="headerlink" title="发布到蒲公英"></a>发布到蒲公英</h3><ul><li>安装插件<code>Upload to pgyer</code></li><li>配置任务，在构建后操作中，选择<code>upload to pgyer with apiV2</code>，配置相关参数即可</li></ul><p><img src="http://chuantu.biz/t6/347/1532335554x-1566688556.jpg" alt="上传蒲公英"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.pgyer.com/doc/view/jenkins" target="_blank" rel="noopener">蒲公英文档</a></li><li><a href="https://blog.csdn.net/u011541946/article/details/78267097" target="_blank" rel="noopener">Android基于Gradle参数化打不同环境安装包</a></li></ul><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件权限</title>
      <link href="/2018/07/03/linux-wen-jian-quan-xian/"/>
      <url>/2018/07/03/linux-wen-jian-quan-xian/</url>
      
        <content type="html"><![CDATA[<p>有一次下载一个工具，点击setup时没有反应，使用命令行打开时提示权限不够。<br>Linux系统对文件的权限做了很详细的区分和敏感处理，因此需要单独去申请权限。<br>常用的命令如下。</p><a id="more"></a>  <h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>列举当前目录文件权限: <code>ls -l</code></li><li>当前目录指定文件权限：<code>chmod a+x filename</code></li><li>指定目录文件权限:<code>chmod 777 /home/pinger</code></li><li>指定目录及该目录下的子目录和子文件的权限:<code>chmod -R 777 /home/pinger</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Github来管理Hexo博客文件</title>
      <link href="/2018/07/03/shi-yong-github-lai-guan-li-hexo-bo-ke-wen-jian/"/>
      <url>/2018/07/03/shi-yong-github-lai-guan-li-hexo-bo-ke-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>Hexo在本地完成初始化和博客编辑，最终是部署在Github上的。<br>如果你换台电脑更新博客就非常麻烦，必须要拷贝博客的代码，重新部署才能生效。<br>有一个办法可以解决这个问题，就是在Github上开一个分之来管理代码文件。</p><a id="more"></a>  <p>Hexo部署在Github上默认是master分支，这个分支是<br>存放Hexo部署后的文件的，并不是本地博客的源文件。</p><p>使用命令<code>git branch hexo</code>新建hexo分支，该将作为存放本地源文件的分支。<br>在master分支上编辑文件，部署发布博客，等博客发布完成后，执行<code>git add .</code><br>和<code>git commit -m &#39;更新内容&#39;</code>把改动的文件添加到本地git仓库。</p><p>执行<code>git checkout hexo</code>，切换到hexo分支，该分支不需要改动任何内容。<br>在hexo分支上执行<code>git merge master</code>合并master分支的文件，<br>执行<code>git push hexo</code>发布到服务器就好了。</p><p>当换台电脑编写博客时，如果是第一次使用，先拉取Github上的代码到本地，配置好Hexo的环境。<br>执行<code>git branch</code>确定当前在哪个分支，如果不在hexo分支，<br>则执行<code>git checkout hexo</code>切换到hexo分支，执行<code>git pull</code>拉取服务器的最新文件。</p><p>切换回master分支，执行<code>git merge hexo</code>，合并hexo分支来拉取最新的源文件，<br>这样就保证了换电脑了，本地的master分支接上了上一次更新的master分支内容。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>master分支用来编辑内容，该分支的文件不需要使用git提交到服务器，而是使用hexo命令部署。</li><li>hexo分支不需要编辑内容，该分支是master分支文件的中转，需要使用git进行提交和拉取。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio添加ShadowSockets代理</title>
      <link href="/2018/05/12/androidstudio-tian-jia-shadowsockets-dai-li/"/>
      <url>/2018/05/12/androidstudio-tian-jia-shadowsockets-dai-li/</url>
      
        <content type="html"><![CDATA[<ul><li>平时使用Android Studio访问的基本都是国外的服务器，网速十分的缓慢。所以一般都会对Studio设置代理，<br>可以直接翻墙访问，速度也是蹭蹭蹭往上涨。</li><li>进入Studio设置界面，搜索proxy，选择http proxy选项。</li><li>选择Automatic proxy configuration url，填入<code>http://127.0.0.1:1080/pac</code>，apply就可以了。</li></ul><a id="more"></a>  <blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一路向南，过我的生活</title>
      <link href="/2018/04/15/yi-lu-xiang-nan-guo-wo-de-sheng-huo/"/>
      <url>/2018/04/15/yi-lu-xiang-nan-guo-wo-de-sheng-huo/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=526472371&auto=0&height=66"></iframe><hr><p>选择学校,一路向北。离开学校，一路向南。</p><p>北方的第一年生活真的不太适应，走在路上都觉得别扭，<br>尤其听着导员的东北口音，感觉自己在炼狱里。<br>逃课应该是从大二开始吧，每天窝在图书馆没日没夜码代码，痛并快乐着。<br>特感谢那一年的我，厚积薄发。<br>大三那年为了考软考高级证书，硬是把２万字的作文背了下来，<br>花了两个学期，拿了两个证书，只是现在并没有用到。</p><p>怀念大学的时光，虽然每天都重复着，<br>但是每天都有不一样的精彩，现在想起来觉得很珍贵。<br>毕业后，大衡和小生在北京做后台，东东在新疆搞大数据，<br>曲博在杭州做后台，承JB在杭州做h5前端，我在深圳做Android开发。</p><a id="more"></a>   <img width="40%" src="http://p6jk8aaz8.bkt.clouddn.com/20180415212044.jpg"><p>刚到深圳时，感觉整个世界只有自己，<br>现在觉得自己很幸运，能遇到好朋友，<br>但也觉得自己很悲哀，不善交际，更没有精力去提高。</p><p>有的时候真的觉得很无聊。<br>所以我一个人去电影院看了《雷神３》和《头号玩家》，<br>电影很不错，而且左右两边都是漂亮妹子。</p><p>很意外，子英居然也在深圳，也很惭愧，我竟一无所知。<br>想起当初离校时的匆忙，也许记得的只有自己吧。</p><p>清明假期，游志勇过来深圳了。<br>据他自己说是先到珠海的东澳岛荒野求生（其实是变天降温刮大风），<br>逃离后来深圳找我们玩的。<br>所以我带了两件外套后，带他到海上世界和欢乐海岸继续吹风。</p><p>我催着子英计划日本旅游，她说年底去，但是我感觉很虚。<br>几个人相聚就差仕进了，他还在南昌上班，<br>他说攒点工作经验就要回去继承家业了。<br>程序猿表示羡慕。</p><img width="40%" src="http://p6jk8aaz8.bkt.clouddn.com/20180415212506.jpg"><p>自己想做很多东西，虽然不一定能做起来，<br>但我还是去注册了一个公司，叫雷播科技。<br>一步一个脚印，只是为了有更丰富的人生。</p><p>没有人会主动迎合普通人，除非你是大神级别，<br>不然你只能去奉承别人。这却是我最讨厌的。<br>我这个人很现实，考虑到的事情基本都是坏的，<br>有时候让我变得很消极，也让我错过了很多的机会。</p><p>像我这样孤僻性格的人，不会讨人喜欢，也没有资格去喜欢别人。</p><p>许久未见，甚是想念，大家都还好吗。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 2018 </tag>
            
            <tag> 旧事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux制作快捷启动方式</title>
      <link href="/2018/04/10/linux-zhi-zuo-kuai-jie-qi-dong-fang-shi/"/>
      <url>/2018/04/10/linux-zhi-zuo-kuai-jie-qi-dong-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>Linux使用的安装程序是.deb后缀的软件，安装这种软件会自动生成启动图标，但是我们自己解压出来的.sh文件<br>就不能够生成快捷启动方式，所以需要制作启动方法。</p><h4 id="Linux默认启动图标位置"><a href="#Linux默认启动图标位置" class="headerlink" title="Linux默认启动图标位置"></a>Linux默认启动图标位置</h4><ul><li>Linux默认的启动图标都在<code>/usr/share/applications</code>这个目录里，使用txt编辑器打开这些文件，发现<br>其实是键值对的文本内容，并且文件的后缀都是<code>.desktop</code>。</li></ul><pre><code>  [Desktop Entry]  Name=studio  Comment=this is Android Studio  Exec=/home/pinger/Develop/Android/android-studio/bin/studio.sh  Icon=/home/pinger/Develop/Android/android-studio/bin/studio.png  Terminal=false  Type=Application  Categories=Application;</code></pre><a id="more"></a>  <ul><li>其中<ul><li>Name表示启动应用的名字</li><li>Exec表示启动程序的入口，要填写完整</li><li>Icon表示启动应用的图标</li></ul></li></ul><h4 id="制作启动图标"><a href="#制作启动图标" class="headerlink" title="制作启动图标"></a>制作启动图标</h4><ul><li>打开文件管理器，进入desktop目录，新建文本文件，将上面内容复制进入，替换Name，Exec和Icon的值，保存关闭。</li><li>修改该文件名为Name的值，后缀为.desktop。确认即可启动该应用。  </li></ul><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下使用Genymotion-ARM架构的模拟器</title>
      <link href="/2018/04/02/linux-xia-shi-yong-genymotion-arm-jia-gou-de-mo-ni-qi/"/>
      <url>/2018/04/02/linux-xia-shi-yong-genymotion-arm-jia-gou-de-mo-ni-qi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在<code>deeplin</code>的<code>Linux</code>系统上使用<code>Genymotion</code>安装程序时，提示<code>Installation error: INSTALL_FAILED_NO_MATCHING_ABIS</code>，<br>意思是没有匹配的架构。Genymotion模拟器使用的是<code>x86</code>架构，所以<code>ARM</code>架构的程序安装不了。<br>解决办法就是给模拟器安装一个<code>ARM</code>架构的转换包。</p></blockquote><ul><li>打开模拟器，可以正常运行，将下载的转换包拖进模拟器，会提示安装，点击安装。</li><li>安装成功后，打开命令行，输入<code>adb shell /system/etc/houdini_patcher.sh</code>。</li><li>重新打开模拟器，再次运行程序，成功安装。<br><a href="https://blog.csdn.net/qq_30707799/article/details/68927892" target="_blank" rel="noopener">参考地址</a><br><a href="http://p6jk8aaz8.bkt.clouddn.com/Genymotion-ARM-Translation.zip" target="_blank" rel="noopener">转换包下载地址</a></li></ul><a id="more"></a>   <blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github添加SSH公钥流程</title>
      <link href="/2018/03/25/github-tian-jia-ssh-gong-yao-liu-cheng/"/>
      <url>/2018/03/25/github-tian-jia-ssh-gong-yao-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p>使用Git操作Github远程仓库时需要登录账号和密码，但是每次操作都需要登录非常麻烦。<br>所幸Github服务器使用了SSH公钥认证，所以只需要在本地生成一份公钥并添加到Github服务器就可以免去重复登录。</p><a id="more"></a>  <h3 id="1-检查本地已有公钥"><a href="#1-检查本地已有公钥" class="headerlink" title="1. 检查本地已有公钥"></a>1. 检查本地已有公钥</h3><ul><li>公钥默认是生成在<code>C:\Users\Administrator\.ssh</code>目录下，检查该目录是否有文件，如果不正确的话可以删除重新生成。</li><li>或者打开<code>Git</code>命令窗口，输入<code>ls -al ~/.ssh</code>会列出.ssh目录的文件。</li></ul><h3 id="2-生成新的SSH公钥"><a href="#2-生成新的SSH公钥" class="headerlink" title="2. 生成新的SSH公钥"></a>2. 生成新的SSH公钥</h3><ul><li><code>git</code>命令行输入<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>，替换成自己在<code>github</code>的邮箱地址，一直确认就会在<code>C:\Users\Administrator\.ssh</code>生成公钥。</li></ul><h3 id="3-添加公钥到代理"><a href="#3-添加公钥到代理" class="headerlink" title="3. 添加公钥到代理"></a>3. 添加公钥到代理</h3><ul><li><code>git</code>命令行输入<code>eval $(ssh-agent -s)</code></li><li><code>git</code>命令行输入<code>ssh-add ~/.ssh/id_rsa</code></li></ul><h3 id="3-复制生成的公钥添加到Github账号"><a href="#3-复制生成的公钥添加到Github账号" class="headerlink" title="3. 复制生成的公钥添加到Github账号"></a>3. 复制生成的公钥添加到Github账号</h3><ul><li><code>git</code>命令行执行<code>cat ~/.ssh/id_rsa.pub</code>可以列出公钥内容，复制。</li><li>或者进入<code>C:\Users\Administrator\.ssh</code>目录，复制<code>id_rsa.pub</code>文件的内容。</li><li>登录Github，在设置里添加公钥即可。</li></ul><h3 id="4-测试是否连接成功"><a href="#4-测试是否连接成功" class="headerlink" title="4. 测试是否连接成功"></a>4. 测试是否连接成功</h3><ul><li><code>git</code>命令行执行<code>ssh -T git@github.com</code>，如果出现<code>Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>就表示成功。</li></ul><h3 id="更多关于Github添加SSH公钥信息"><a href="#更多关于Github添加SSH公钥信息" class="headerlink" title="更多关于Github添加SSH公钥信息"></a>更多关于Github添加SSH公钥信息</h3><ul><li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">Github添加SSH公钥官方教程</a></li><li><a href="https://help.github.com/categories/authenticating-to-github/" target="_blank" rel="noopener">Github添加SSH公钥常见问题</a></li></ul><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2018 </tag>
            
            <tag> 开发 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之App启动优化</title>
      <link href="/2017/12/19/kai-fa-ji-lu-zhi-app-qi-dong-you-hua/"/>
      <url>/2017/12/19/kai-fa-ji-lu-zhi-app-qi-dong-you-hua/</url>
      
        <content type="html"><![CDATA[<hr><p>项目重构App的启动，之前的处理是使用SplashActivity作为过渡页，然后将Application中的第三方SDK放到IntentService中加载，<br>启动过程中的一些耗时操作也都去掉了，奈何MainActivity中的业务逻辑还是太过复杂，启动仍然比较漫长。<br>研究了一下<code>淘宝</code>项目的启动处理，总结出一种非常优化的App启动方案。</p><h3 id="传统的启动处理"><a href="#传统的启动处理" class="headerlink" title="传统的启动处理"></a><code>传统的启动处理</code></h3><p>市面上大部分的App启动处理如出一辙，基本都是先进入SplashActivity，然后Handler延时后跳转到MainActivity。</p><a id="more"></a>   <p>这样做的好处是SplashActivity作为过渡页更加轻量，启动到显示界面的时间更短，给用户较好的体验，而且SplashActivity中也可以提前做一些数据处理，减轻MainActivity的压力。但是加入SplashActivity过渡页也有一些缺点，比如要多绘制一个页面，要使用Intent传递数据，不能减轻MainActivity页面的绘制压力和一些数据加载。<br><img src="http://oibrygxgr.bkt.clouddn.com/app_lun1.png" alt="Alt text"></p><p>除此之外，Application的处理也是一个很重要的点，因为App启动是先走Application的onCreate方法的，如果onCreate中加载SDK的时间过于漫长，就会导致App启动后显示一段时间白屏页才会进入SplashActivity，当然也可以使用windowBackGround属性避免白屏，但是时间长了总是会影响用户体验的。所以Application中一般都是采用IntentService来加载SDK的。</p><p>为了解决App启动慢和SplashActivity过渡启动的缺点，个人去研究了一下淘宝的启动，发现第一次启动耗时大概3秒，然后退出去，再进入时就不会显示Splash，直接进入主页读取缓存显示页面。我猜测淘宝的启动肯定是根据应用的进程是否存活，如果存活就直接进入MainActivity，否则显示Splash，而且淘宝的Splash加载很快，MainActivity的加载也很快，所以淘宝应该是采用了Splash绑定在Mainactivity上的方式，即<code>SplashFragment+StubView</code>的方式启动App。</p><h3 id="优化后的Splash"><a href="#优化后的Splash" class="headerlink" title="优化后的Splash"></a><code>优化后的Splash</code></h3><p>传统的App启动方式不足以满足现在用户的体验，用户需要的是加载更快，性能更优的体验，所以这里采用SplashFragment+StubView的方式去实现App的快速启动。<br><img src="http://oibrygxgr.bkt.clouddn.com/app_lun2.png" alt="Alt text"></p><p>跟传统启动方式最大的不同是，优化后的启动会直接进入MainActivity，然后在MainActivity控制Splash的显示隐藏，这样在填充Splash的时候还以为直接加载MainActivity的数据，当窗体填充完毕之后，就可以绘制MainActivity的布局，然后移除Splash，展示页面，这种方式很好的体现了异步的操作，使得填充和加载分离，启动的速度更快。</p><p>既然知道了这种实现方式，那具体代码是如何编写的呢，接下来看一下如何实现。</p><h4 id="1-填充SplashFragment"><a href="#1-填充SplashFragment" class="headerlink" title="1. 填充SplashFragment"></a>1. 填充SplashFragment</h4><p>在MainActivity的onCreate方法中，首先，需要做的就是填充Splash并显示，显示的内容就可以在SplashFragment中编辑。</p><pre><code>    log.d(TAG, &quot;==========填充SplashFragment==========&quot;);    // 1.初始化SplashFragment，填充Splash    final SplashFragment splashFragment = new SplashFragment();    getFragmentManager().beginTransaction().replace(R.id.container,splashFragment).commitAllowingStateLoss();</code></pre><h4 id="2-窗体部署完毕，填充主页布局"><a href="#2-窗体部署完毕，填充主页布局" class="headerlink" title="2. 窗体部署完毕，填充主页布局"></a>2. 窗体部署完毕，填充主页布局</h4><p>当整个页面最底层DecorView填充完毕之后，就可以开始去填充MainActivity的布局了，并且使用Handler发送延时消息，2秒后移除Splash。当然移除Splash也可以直接在数据加载完毕显示页面之前移除掉。</p><pre><code>    getWindow().getDecorView().post(new Runnable() {        @Override        public void run() {            // 填充布局            viewStub.inflate();            // 初始化布局            initView();            // 2秒后移除Splash            mHandler.postDelayed(new DelayRunnable(MainActivity.this, splashFragment), 2000);        }    });</code></pre><h3 id="3-加载MainActivity数据"><a href="#3-加载MainActivity数据" class="headerlink" title="3. 加载MainActivity数据"></a>3. 加载MainActivity数据</h3><p>其实加载数据会在第二步之前执行，因为第二步是异步操作，并且加载数据是耗时操作，所以需要更早执行，不要放在第二步里去执行，这里在测试的时候有可能数据先加载完毕，布局才绘制完，调用控件就会有空指针问题，但是实际开发中肯定不会出现这种情况的，MainActivity中的数据加载肯定很耗时。</p><h3 id="Application的优化"><a href="#Application的优化" class="headerlink" title="Application的优化"></a><code>Application的优化</code></h3><p>Application是应用的核心枢纽，应用启动时会先走Application的onCreate方法去初始化一些全局数据，比如SDK等等。但是当全局数据很多时，App的启动就会变得缓慢，因为初始化是同步加载的，所以要想加快启动，就需要将延时操作放到后台去处理。</p><p>Android里有一个Service，正好可以做延时处理的操作，这个Service就是IntentService。关于IntentService，不了解的看这里。<br><a href="http://www.jianshu.com/p/332b6daf91f0" target="_blank" rel="noopener">IntentService 示例与详解</a><br><a href="https://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="noopener">IntentService文档</a></p><p>接下来，看一下如何实现。</p><ul><li><p>自定义InitializeService继承IntentService，实现构造和方法onHandleIntent</p></li><li><p>在Application的onCreate方法中启动初始化服务</p></li></ul><pre><code>     // 启动服务去做耗时操作     InitializeService.start(this);     public static void start(Context context) {           Intent intent = new Intent(context, InitializeService.class);            intent.setAction(ACTION_APP_LAUNCHER);            context.startService(intent);     }</code></pre><ul><li>在onHandleIntent方法中判断Intent，然后去初始化SDK</li></ul><pre><code>     @Override      protected void onHandleIntent(@Nullable Intent intent) {          if (intent != null) {                final String action = intent.getAction();                if (ACTION_APP_LAUNCHER.equals(action)) {                    performInit();                }          }      }        /**         * 启动初始化耗时操作         */        private void performInit() {            // 模拟延时加载            SystemClock.sleep(2000);            Log.d(TAG, &quot;==========初始化第三方SDK结束==========&quot;);         }</code></pre><p><code>注意：</code></p><ul><li>在清单文件中配置Application和Service</li><li>并不是所有的SDK都能放到Service中去初始化的，在MainActivity中用到的还是需要提前初始化</li></ul><p><a href="https://github.com/PingerOne/android_develop_sample.git" target="_blank" rel="noopener">Demo下载地址</a></p><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过客，一个人的朝圣</title>
      <link href="/2017/09/14/guo-ke-yi-ge-ren-de-zhao-sheng/"/>
      <url>/2017/09/14/guo-ke-yi-ge-ren-de-zhao-sheng/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=471797594&auto=0&height=66"></iframe>---<p>没有谁能够想到 你会出现我身旁<br>也许是命运开的玩笑 不敢太靠近你的身边<br>怕你会嫌烦 只有一个人默默孤单<br>是什么让我们遇见的 是什么让距离更近了<br>不奢求你多好 给我多一点微笑</p><a id="more"></a>   <p>你只是一个过客 从我的世界路过<br>我不敢太多不舍 怕你看出我难过<br>也许我想的太多 却不能给你什么<br>努力把伤心变少 笑容变多就好了<br>我只是个陪伴者 陪着你伤心难过<br>寂寞它每天数着 你那么多的失落<br>你想要什么你说 只要我现在有的<br>我们之间的点点滴滴 我一直都记得</p><p>不敢太靠近你的身边 怕你会嫌烦<br>只有 一个人默默孤单<br>是什么让我们遇见的 是什么让距离更近了<br>不奢求你多好 再多给我一点微笑</p><p>我只是一个过客 从你的世界路过<br>我不敢太多不舍 怕你看出我难过<br>我想的太多 却不能给你什么<br>努力把伤心变少 笑容变多就好了<br>我只想每天陪着 陪着你伤心难过<br>寂寞它每天数着 你那么多的失落<br>你想要什么你说 只要我现在有的<br>我们之间的点点滴滴 我一直都记得</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 旧事 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凉城，叙事</title>
      <link href="/2017/09/12/liang-cheng-xu-shi/"/>
      <url>/2017/09/12/liang-cheng-xu-shi/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=551347831&auto=0&height=66"></iframe>---<p>站在雨中目送你穿过那渡口<br>离岸的船舶漂走远去的轮廓<br>惆怅惹灯火 往事渐落寞<br>烟波起落 被遗忘的是我</p><a id="more"></a>   <p>十里洋场的繁华依旧<br>这幅光景也掩不去我的难过<br>曾陪我看过 老街的烟火<br>缘分蹉跎 花难结果</p><p>当海风吹凉霓虹 回首你无影踪<br>转眼旧盟已成空 赏夜色千家朦胧<br>风花雪月如梦 提醒我也曾爱过<br>任眼泪划伤面容 飘浮在情海中<br>横渡春夏与秋冬 这城市车水马龙<br>我心事无人懂 回忆让人更心痛</p><p>凉城中 不夜城的邂逅未断过<br>而你的温柔却早已年久失修<br>弄堂诉离愁 苔痕如伤口<br>我在那头 等你很久</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 旧事 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之沉浸式状态栏最简单实现</title>
      <link href="/2017/08/17/kai-fa-ji-lu-zhi-chen-jin-shi-zhuang-tai-lan-zui-jian-dan-shi-xian/"/>
      <url>/2017/08/17/kai-fa-ji-lu-zhi-chen-jin-shi-zhuang-tai-lan-zui-jian-dan-shi-xian/</url>
      
        <content type="html"><![CDATA[<hr><p>网上有很多对于沉浸式状态栏的讲解，也有很多实现沉浸式状态栏的方法。<br>具体的原理可以参考几篇分析的比较不错的文章：<br><a href="http://www.jianshu.com/p/f3683e27fd94" target="_blank" rel="noopener">Android沉浸式UI实现及原理</a><br><a href="http://www.jianshu.com/p/34a8b40b9308" target="_blank" rel="noopener">Android 系统状态栏沉浸式/透明化完整解决方案</a></p><p>这里将两种实现起来比较简单的方式贴出来，可以直接拿去使用。</p><a id="more"></a>  <h3 id="通过代码进行设置"><a href="#通过代码进行设置" class="headerlink" title="通过代码进行设置"></a>通过代码进行设置</h3><ul><li>在想要实现透明状态栏的Activity里，或者BaseActivity里的setContentView()方法后调用如下代码</li></ul><!-- more -->  <pre><code>  // 设置状态栏，仅支持到4.4以上版本的Android系统，即API19  public static void initStatus(Activity activity) {      if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {          activity.getWindow().setFlags(                  WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,                  WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);      }  }</code></pre><ul><li>以上代码会把整个状态栏去掉，所以需要在布局文件里的ToolBar设置paddingTop的属性，statusBarSize=25dp</li></ul><pre><code>  android:paddingTop=&quot;@dimen/statusBarSize&quot;</code></pre><ul><li>由于透明状态栏是Google在Android 4.4之后才支持的，所以需要根据不同的版本设置statusBarSize的大小，新建values-v19文件夹，将dimen文件的statusBarSize改成0p就好了</li></ul><h3 id="通过配置主题进行设置"><a href="#通过配置主题进行设置" class="headerlink" title="通过配置主题进行设置"></a>通过配置主题进行设置</h3><ul><li>在values文件中设置AppTheme</li></ul><pre><code>  &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;     &lt;!-- Customize your theme here. --&gt;     &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;     &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;     &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;     &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;  &lt;/style&gt;</code></pre><ul><li>在res下新建一个values-v19文件夹，然后新建values.xml文件，设置AppTheme，这是兼容到4.4版本的写法</li></ul><pre><code>  &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;      &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;      &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;      &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;      &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;      &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;      &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;  &lt;/style&gt;</code></pre><ul><li>在res下新建一个values-v21文件夹，然后新建values.xml文件，设置AppTheme，兼容5.0的写法</li></ul><pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;     &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;     &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;     &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;     &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;     &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;false&lt;/item&gt;     &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;     &lt;!--Android 5.x开始需要把颜色设置透明，否则导航栏会呈现系统默认的浅灰色--&gt;     &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt;</code></pre><ul><li>同理，以上代码也会把整个状态栏去掉，所以还需要在布局文件里的根容器下设置如下代码，然后在values-v19文件夹中将dimen文件的statusBarSize改成0p就好了</li></ul><pre><code>   android:paddingTop=&quot;@dimen/statusBarSize&quot;</code></pre><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之Android重力感应横竖屏</title>
      <link href="/2017/08/13/kai-fa-ji-lu-zhi-android-chong-li-gan-ying-heng-shu-ping/"/>
      <url>/2017/08/13/kai-fa-ji-lu-zhi-android-chong-li-gan-ying-heng-shu-ping/</url>
      
        <content type="html"><![CDATA[<hr><p>开发时遇到播放视频要用重力感应来横竖屏，并且要有按钮点击横竖屏，查了很多资料，并参考了网上一些实现思路，终于把重力感应横竖屏完整实现，现封装成工具类，可以直接使用。</p><h3 id="一、实现原理"><a href="#一、实现原理" class="headerlink" title="一、实现原理"></a>一、实现原理</h3><blockquote><p>既然是重力感应横竖屏，那就肯定要有重力感应，重力感应属于传感器的一类，所以需要用到重力感应传感器，不清楚的同学可以google一下。由于视频播放或者直播页面一直都需要重力感应，所以还需要绑定播放页面的生命周期来注册重力感应和注销重力感应。这样当注册重力感应后，就可以获取当前屏幕的朝向角度，根据这些角度来判断哪个范围需要横竖屏。</p></blockquote><a id="more"></a>   <h3 id="二、实现逻辑"><a href="#二、实现逻辑" class="headerlink" title="二、实现逻辑"></a>二、实现逻辑</h3><h4 id="2-1-打造工具类ScreenRotateUtil"><a href="#2-1-打造工具类ScreenRotateUtil" class="headerlink" title="2.1 打造工具类ScreenRotateUtil"></a>2.1 打造工具类ScreenRotateUtil</h4><ul><li><p>由于要绑定生命周期，并且可以点击横竖屏，所以可以做一个工具类，提供start()和stop方法来绑定生命周期，并且暴露一个点击切换横竖屏的方法toggleRotate()就可以。</p></li><li><p>start方法注册监听</p></li></ul><pre><code>    public void start(Activity activity) {        // 接收activity，用于操作屏幕的旋转        mActivity = activity;        // 注册传感器监听        sm.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_UI);    }</code></pre><ul><li>stop()方法注销监听</li></ul><pre><code>    public void stop() {        // 注销监听        sm.unregisterListener(listener);        // 防止内存泄漏        mActivity = null;    }</code></pre><ul><li>toggleRotate()方法，自动切换横竖屏</li></ul><pre><code>    public void toggleRotate() {        /**         * 先判断是否已经开启了重力感应，没开启就直接普通的切换横竖屏         */        if(isEffetSysSetting){            try {                int isRotate = Settings.System.getInt(mActivity.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION);                // 如果用户禁用掉了重力感应就直接切换                if (isRotate == 0) {                    changeOrientation(isLandscape, true);                    return;                }            } catch (Settings.SettingNotFoundException e) {                e.printStackTrace();            }        }        /**         * 如果开启了重力感应就需要修改状态         */        isOpenSensor = false;        isClickFullScreen = true;        if (isChangeOrientation) {            changeOrientation(isLandscape, false);        } else {            isLandscape = !isLandscape;            changeOrientation(isLandscape, false);        }    }</code></pre><h4 id="2-2-重力感应传感器"><a href="#2-2-重力感应传感器" class="headerlink" title="2.2 重力感应传感器"></a>2.2 重力感应传感器</h4><blockquote><p>Android提供了多种传感器，这里只是简单介绍一下重力感应传感器，想了解更多请<a href="http://blog.csdn.net/mad1989/article/details/20848181" target="_blank" rel="noopener">传送</a>。</p></blockquote><ul><li>初始化传感器</li></ul><pre><code>    // 这里在构造里初始化重力重力感应    private ScreenRotateUtil(Context context) {        // 获取传感器管理器        sm = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);        // 获取传感器类型        sensor = sm.getDefaultSensor(Sensor.TYPE_GRAVITY);        // 初始化监听器        listener = new OrientationSensorListener(mHandler);    }</code></pre><ul><li><p>start()方法注册监听，stop()方法注销监听</p></li><li><p>看一下监听里非常重要的方法onSensorChanged，当注册了监听后，这个方法会不停的回调用，不停的给Handler发送消息，然后就可以在Handler里修改屏幕的朝向</p></li></ul><pre><code>    public void onSensorChanged(SensorEvent event) {        float[] values = event.values;        int orientation = ORIENTATION_UNKNOWN;        float X = -values[_DATA_X];        float Y = -values[_DATA_Y];        float Z = -values[_DATA_Z];        float magnitude = X * X + Y * Y;        // Don&#39;t trust the angle if the magnitude is small compared to the y        // value        if (magnitude * 4 &gt;= Z * Z) {            // 屏幕旋转时            float OneEightyOverPi = 57.29577957855f;            float angle = (float) Math.atan2(-Y, X) * OneEightyOverPi;            orientation = 90 - Math.round(angle);            // normalize to 0 - 359 range            while (orientation &gt;= 360) {                orientation -= 360;            }            while (orientation &lt; 0) {                orientation += 360;            }        }        /**         * 获取手机系统的重力感应开关设置，这段代码看需求，不要就删除         * screenchange = 1 表示开启，screenchange = 0 表示禁用         * 要是禁用了就直接返回         */        if(isEffetSysSetting){            try {                int isRotate = Settings.System.getInt(mActivity.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION);                // 如果用户禁用掉了重力感应就直接return                if (isRotate == 0) return;            } catch (Settings.SettingNotFoundException e) {                e.printStackTrace();            }        }        // 只有点了按钮时才需要根据当前的状态来更新状态        if (isClickFullScreen) {            if (isLandscape &amp;&amp; screenIsPortrait(orientation)) {           // 之前是横屏，并且当前是竖屏的状态                Log.d(TAG, &quot;onSensorChanged: 横屏 ----&gt; 竖屏&quot;);                updateState(false, false, true, true);            } else if (!isLandscape &amp;&amp; screenIsLandscape(orientation)) {  // 之前是竖屏，并且当前是横屏的状态                Log.d(TAG, &quot;onSensorChanged: 竖屏 ----&gt; 横屏&quot;);                updateState(true, false, true, true);            } else if (isLandscape &amp;&amp; screenIsLandscape(orientation)) {    // 之前是横屏，现在还是横屏的状态                Log.d(TAG, &quot;onSensorChanged: 横屏 ----&gt; 横屏&quot;);                isChangeOrientation = false;            } else if (!isLandscape &amp;&amp; screenIsPortrait(orientation)) {  // 之前是竖屏，现在还是竖屏的状态                Log.d(TAG, &quot;onSensorChanged: 竖屏 ----&gt; 竖屏&quot;);                isChangeOrientation = false;            }        }        // 判断是否要进行中断信息传递        if (!isOpenSensor) {            return;        }        if (rotateHandler != null) {            rotateHandler.obtainMessage(888, orientation, 0).sendToTarget();        }    }</code></pre><h3 id="2-3-横竖屏处理"><a href="#2-3-横竖屏处理" class="headerlink" title="2.3 横竖屏处理"></a>2.3 横竖屏处理</h3><ul><li>这里的横竖屏是去根据当前手机的朝向即orientation的角度进行判断，然后调用mActivity.setRequestedOrientation()方法设置横竖屏，这里进行了360°的判断，实现了四个方向的横竖屏。</li></ul><pre><code>     if (msg.what == 888) {        int orientation = msg.arg1;        /**         * 根据手机屏幕的朝向角度，来设置内容的横竖屏，并且记录状态         */        if (orientation &gt; 45 &amp;&amp; orientation &lt; 135) {            mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);            isLandscape = true;        } else if (orientation &gt; 135 &amp;&amp; orientation &lt; 225) {            mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);            isLandscape = false;        } else if (orientation &gt; 225 &amp;&amp; orientation &lt; 315) {            mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);            isLandscape = true;        } else if ((orientation &gt; 315 &amp;&amp; orientation &lt; 360) || (orientation &gt; 0 &amp;&amp; orientation &lt; 45)) {            mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);            isLandscape = false;        }    }</code></pre><h3 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h3><ol><li>Activity的onResume()方法调用start()方法进行注册监听</li><li>Activity的onPause()方法调用stop()方法注销监听</li><li>点击全屏按钮时调用toggleRotate()自动切换横竖屏</li><li>如果需要手机系统的横竖屏按钮生效则调用setEffetSysSetting(true)</li></ol><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>关于重力感应横竖屏其实并不是很难，根据实际的需求去做，一步一步考虑逻辑。这个工具类也基本上是没用什么bug，也可以直接拿去用。如果对你有用可以到我的<a href="https://github.com/PingerOne/ScreenRotation" target="_blank" rel="noopener">Github</a>给个star哦，有什么问题欢迎issues哦。</p><p><a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">我的主页</a><br><a href="https://github.com/PingerOne/ScreenRotation" target="_blank" rel="noopener">Demo下载</a></p><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之Activity的转场动画实现</title>
      <link href="/2017/06/22/kai-fa-ji-lu-zhi-activity-de-zhuan-chang-dong-hua-shi-xian/"/>
      <url>/2017/06/22/kai-fa-ji-lu-zhi-activity-de-zhuan-chang-dong-hua-shi-xian/</url>
      
        <content type="html"><![CDATA[<hr><p>关于Google提供的动画框架，请上传送门，<a href="http://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&mid=2651940687&idx=1&sn=843fcc9cf508751ec2aab7fe059e9436&chksm=84fd75abb38afcbd3b814127a3401d260e8700240289a44ac6156c1daf0a93f1b4e7e0a20e49&scene=0#rd" target="_blank" rel="noopener">Android Transition Framework详解—超炫的动画框架</a></p><p>其中对于Activity的跳转有了很不错的讲解，所以具体请查看动画框架，这里只是简单的讲一下三种跳转方式的实现和应用，<br>实际开发中用的比较多的还是通过主题配置的方式，可以进行全局使用，个别独特的跳转就需要使用动画框架，不过实现了就特别炫。</p><a id="more"></a>   <h2 id="一、通过Theme进行配置（开发中最常用的方式）"><a href="#一、通过Theme进行配置（开发中最常用的方式）" class="headerlink" title="一、通过Theme进行配置（开发中最常用的方式）"></a>一、通过Theme进行配置（开发中最常用的方式）</h2><h3 id="1、写好跳转动画，采用帧动画的形式"><a href="#1、写好跳转动画，采用帧动画的形式" class="headerlink" title="1、写好跳转动画，采用帧动画的形式"></a>1、写好跳转动画，采用帧动画的形式</h3><ul><li>在anim文件夹下创建xml文件，使用set动画集来配置动画</li><li>slide_left_in.xml(Activity从左侧进入的动画)</li></ul><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;translate      android:duration=&quot;300&quot;      android:fromXDelta=&quot;-100.0%p&quot;      android:toXDelta=&quot;0.0&quot;/&gt;  &lt;/set&gt;</code></pre><ul><li>slide_state.xml(Activity保持不变)</li></ul><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;translate    android:duration=&quot;300&quot;    android:fromXDelta=&quot;0&quot;    android:toXDelta=&quot;0&quot;/&gt;  &lt;/set&gt;</code></pre><h3 id="2、配置跳转Activity的主题"><a href="#2、配置跳转Activity的主题" class="headerlink" title="2、配置跳转Activity的主题"></a>2、配置跳转Activity的主题</h3><ul><li>首先在清单文件中，找到指定的Activity，并配置其主题</li></ul><pre><code>  &lt;activity       android:name=&quot;.ui.activity.TestActivity&quot;       android:theme=&quot;@style/ActivityTheme&quot;/&gt;</code></pre><ul><li>其次在style.xml文件中进行设置</li></ul><pre><code>  &lt;!--配置单个Activity的跳转动画，可以在AppTheme里配置所有Activity的跳转--&gt;  &lt;style name=&quot;ActivityTheme&quot; parent=&quot;AppTheme&quot;&gt;      &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/activityAnim&lt;/item&gt;  &lt;/style&gt;  &lt;!--配置各种方式的跳转动画--&gt;  &lt;style name=&quot;activityAnim&quot;&gt;      &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/slide_right_in&lt;/item&gt;      &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@anim/slide_state&lt;/item&gt;      &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@anim/slide_state&lt;/item&gt;      &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/slide_right_out&lt;/item&gt;  &lt;/style&gt;  &lt;!--activityOpenEnterAnimation ：activity打开时进入的动画--&gt;  &lt;!--activityOpenExitAnimation  ：activity打开时退出的动画--&gt;  &lt;!--activityCloseEnterAnimation ：activity关闭时进入的动画--&gt;  &lt;!--activityCloseExitAnimation  ：activity关闭时退出的动画--&gt;</code></pre><h2 id="二、overridePendingTransition-方法进行设置"><a href="#二、overridePendingTransition-方法进行设置" class="headerlink" title="二、overridePendingTransition()方法进行设置"></a>二、overridePendingTransition()方法进行设置</h2><ul><li><p>在startActivity()和finish()之后可以调用overridePendingTransition()处理跳转动画，这个方法接收两个参数，一个是新启动的activity进入时的动画，另一个是当前activity消失时的动画。</p></li><li><p>启动</p></li></ul><pre><code>  startActivity(new Intent(this, TestActivity.class));  overridePendingTransition(R.anim.slide_right_in, R.anim.slide_state);</code></pre><ul><li>退出</li></ul><pre><code>  finish();  overridePendingTransition(R.anim.slide_right_out, R.anim.slide_state);</code></pre><h2 id="三、谷歌提供的Activity动画类ActivityOptionsCompat"><a href="#三、谷歌提供的Activity动画类ActivityOptionsCompat" class="headerlink" title="三、谷歌提供的Activity动画类ActivityOptionsCompat"></a>三、谷歌提供的Activity动画类ActivityOptionsCompat</h2><ul><li><p>ActivityOptionsCompat是supportv4中新加的一个类，可以为activity添加各种动画效果，里面的api至少要求4.0，部分要求5.0以上，谷歌为我们封装好了的一些拉伸扩散动画，共享元素动画等等。</p></li><li><p>启动</p></li></ul><pre><code>    ActivityOptionsCompat compat = ActivityOptionsCompat.makeCustomAnimation(_mActivity,R.anim.slide_right_in,R.anim.slide_state);    ActivityCompat.startActivity(_mActivity,new Intent(_mActivity,TestActivity.class),compat.toBundle());</code></pre><ul><li>退出</li></ul><pre><code>    ActivityCompat.finishAfterTransition(this);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用时一般是通过配置Theme的方式，在AppTheme里配置所有Activity的跳转动画，进行统一管理，如果需要对某个Activity进行特殊处理，可以使用overridePendingTransition或者ActivityOptionsCompat进行单独设置。</p><p>动画执行优先级：系统动画 &lt; AppTheme &lt; (overridePendingTransition\ActivityOptionsCompat)。</p><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之自定义scrollbars样式</title>
      <link href="/2017/05/20/kai-fa-ji-lu-zhi-zi-ding-yi-scrollbars-yang-shi/"/>
      <url>/2017/05/20/kai-fa-ji-lu-zhi-zi-ding-yi-scrollbars-yang-shi/</url>
      
        <content type="html"><![CDATA[<hr><p>由于项目之前引用了一些很老的系统主题，所以显示的scrollbars样式特别的丑，于是我决定自己去自定义一个好看一点的，实现起来也是蛮简单的。</p><p>scrollbars是View自带的一个属性，所以只需要定义一套，之后所有有scrollbars属性的控件都可以使用，当然也可以定制多套，只需要使用shape属性指定颜色就可以。</p><a id="more"></a>  <h3 id="1，使用shape绘制scrollbar的灰色样式"><a href="#1，使用shape绘制scrollbar的灰色样式" class="headerlink" title="1，使用shape绘制scrollbar的灰色样式"></a>1，使用shape绘制scrollbar的灰色样式</h3><ul><li>scrollbar_vertical_thumb.xml文件如下：</li></ul><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;      android:shape=&quot;rectangle&quot;&gt;      &lt;solid android:color=&quot;#55000000&quot;/&gt;      &lt;corners android:radius=&quot;1dp&quot; /&gt;  &lt;/shape&gt;</code></pre><h3 id="2，在需要使用的控件里调用"><a href="#2，在需要使用的控件里调用" class="headerlink" title="2，在需要使用的控件里调用"></a>2，在需要使用的控件里调用</h3><ul><li>比如ListView的自定义scrollbar写法</li></ul><pre><code>  &lt;ListView      android:id=&quot;@id/list&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;      android:clickable=&quot;true&quot;      android:overScrollMode=&quot;never&quot;      android:scrollbarSize=&quot;@dimen/scroll_bar_size&quot;      android:scrollbarThumbVertical=&quot;@drawable/scrollbar_vertical_thumb&quot;/&gt;</code></pre><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之RecyclerView的overScrollMode与scrollbars显示冲突</title>
      <link href="/2017/04/28/kai-fa-ji-lu-zhi-recyclerview-de-overscrollmode-yu-scrollbars-xian-shi-chong-tu/"/>
      <url>/2017/04/28/kai-fa-ji-lu-zhi-recyclerview-de-overscrollmode-yu-scrollbars-xian-shi-chong-tu/</url>
      
        <content type="html"><![CDATA[<hr><p>在使用RecyclerView时，使用overScrollMode=”never”去掉阴影，之后发现scrollbars不显示了，google后找到了解决方式。</p><h3 id="1、有问题的RecyclerView布局"><a href="#1、有问题的RecyclerView布局" class="headerlink" title="1、有问题的RecyclerView布局"></a>1、有问题的RecyclerView布局</h3><ul><li>RecyclerView布局如下</li></ul><pre><code>  &lt;android.support.v7.widget.RecyclerView      android:id=&quot;@id/list&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;      android:overScrollMode=&quot;never&quot;      android:scrollbars=&quot;vertical&quot;/&gt;</code></pre><a id="more"></a>  <h3 id="2、解决方式"><a href="#2、解决方式" class="headerlink" title="2、解决方式"></a>2、解决方式</h3><ul><li>解决方法很简单，将RecyclerView背景设置成透明就好了</li></ul><pre><code>    android:background=&quot;@android:color/transparent&quot;</code></pre><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那几年</title>
      <link href="/2017/02/26/na-ji-nian/"/>
      <url>/2017/02/26/na-ji-nian/</url>
      
        <content type="html"><![CDATA[<p>到现在，两年十二个月十二天，已物事人非。<br>虽然放下，但是永远记得并且遗憾，没能和你走到最后。<br>离开后，我听过的每一首歌，看过的每一个故事，沿路的风景，都会让我想起你。<br>对不起，是我没有勇气拥抱你。<br>多年后，祝福另一座城市的你，幸福快乐。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 旧事 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>此时此刻还在奋斗的你</title>
      <link href="/2017/02/22/ci-shi-ci-ke-huan-zai-nu-li-de-ni/"/>
      <url>/2017/02/22/ci-shi-ci-ke-huan-zai-nu-li-de-ni/</url>
      
        <content type="html"><![CDATA[<iframe height="360" width="540" src="http://player.youku.com/embed/XMTgzMDU3MzE2OA==" frameborder="0" 'allowfullscreen'></iframe><hr><p>我从来不说话，因为我害怕，没有人回答<br>我从来不挣扎，因为我知道，这世界太大</p><p>最渺小的我，有大大的梦<br>时间向前走，一定只有路口没有尽头<br>纷纷扰扰这个世界，所有的了解<br>只要，让我留在你身边，都陪你渡过</p><a id="more"></a>   <p>最渺小的我，最卑微的梦<br>我发现这世界，没有那么那么的不同<br>现实如果对你不公，别计较太多<br>走吧，暴风雨后的彩虹<br>也许会落空，也许会普通，也许这庸庸碌碌的黑白世界你不懂<br>生命中所有的路口，绝不是尽头<br>别怕，让我留在你身边，都陪你渡过</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之Git常用命令（使用收集中）</title>
      <link href="/2017/02/01/kai-fa-ji-lu-zhi-git-chang-yong-ming-ling-shi-yong-shou-ji-zhong/"/>
      <url>/2017/02/01/kai-fa-ji-lu-zhi-git-chang-yong-ming-ling-shi-yong-shou-ji-zhong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>刚接触Git不久，现在天天都在使用，把用到的命令和踏过的坑列出来，希望一起进步。</p></blockquote><h3 id="常用的Clone、Pull、Push命令"><a href="#常用的Clone、Pull、Push命令" class="headerlink" title="常用的Clone、Pull、Push命令"></a>常用的Clone、Pull、Push命令</h3><ul><li>clone主分支[origin]</li></ul><pre><code>    // 默认主机是origin    git clone  https://github.com/PingerOne/ImageGo.git    // 使用 -o 来指定主机    git clone -o master https://github.com/PingerOne/ImageGo.git</code></pre><ul><li>clone具体的某一个分支[develop_vote分支]</li></ul><pre><code>    git clone -b develop_vote https://github.com/PingerOne/ImageGo.git</code></pre><a id="more"></a>   <ul><li>fetch，将服务器代码拉下来，不会与本地代码合并（常用来查看别人的进程）</li></ul><pre><code>    git fetch origin develop_vote</code></pre><ul><li>Pull下来，会先fetch，然后merge</li></ul><pre><code>    git pull origin develop_vote</code></pre><ul><li>Push上去，推送到远程develop_vote分支</li></ul><pre><code>    git push origin develop_vote</code></pre><h3 id="使用Git在GitHub上新建分支"><a href="#使用Git在GitHub上新建分支" class="headerlink" title="使用Git在GitHub上新建分支"></a>使用Git在GitHub上新建分支</h3><ul><li>在本地新建一个分支</li></ul><pre><code>    git branch develop_refresh   </code></pre><ul><li>切换到新分支</li></ul><pre><code>    git checkout develop_refresh</code></pre><ul><li>将新分支发布在github上</li></ul><pre><code>    git push origin develop_refresh</code></pre><h3 id="使用Git在GitHub上删除分支"><a href="#使用Git在GitHub上删除分支" class="headerlink" title="使用Git在GitHub上删除分支"></a>使用Git在GitHub上删除分支</h3><ul><li>在本地删除一个分支</li></ul><pre><code>    git branch -d develop_refresh</code></pre><ul><li>在github远程端删除一个分支</li></ul><pre><code>    git push origin :develop_refresh   (分支名前的冒号代表删除)</code></pre><h3 id="使用Git删除远程服务器文件和文件夹"><a href="#使用Git删除远程服务器文件和文件夹" class="headerlink" title="使用Git删除远程服务器文件和文件夹"></a>使用Git删除远程服务器文件和文件夹</h3><ul><li>指定文件名字或者文件夹名字</li></ul><pre><code>    git rm --cached fileName/-r directoryName</code></pre><ul><li>提交</li></ul><pre><code>    git commit &quot;删除xx文件/xx文件夹&quot;    git push</code></pre><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Git </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017开年计划　大年初一</title>
      <link href="/2017/01/28/2017-kai-nian-ji-hua/"/>
      <url>/2017/01/28/2017-kai-nian-ji-hua/</url>
      
        <content type="html"><![CDATA[<p>过了一个多灾多难但又不平凡的2016，迎来了更有活力的2017。<br>今年是我的本命年，我希望能有个好的开头，也有个好的结束。<br>故列出今年计划要做的事情，我会尽最大的努力去实现。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><ul><li>学习Android底层架构，学习Android新技术</li><li>学会后台开发，自己写一个网站并且发到服务器</li><li>学会前端开发，完善自己的博客</li><li>学习机器学习深度学习</li><li>自己开发一个App并且尝试运营</li></ul><a id="more"></a>   <h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><ul><li>把深圳逛遍，各种旅游景点都来一发</li><li>去香港旅游</li><li>如果可能，出一趟国，体验一下异国的风情</li></ul><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><ul><li>Android相关书籍</li><li>村上春树三部曲</li><li>其他遇到的书籍</li></ul><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><ul><li>加强英语能力</li><li>学习日语，考过N2</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>学会一些舞蹈</li><li>学会唱一些喜欢的歌，最好能学会一门乐器</li><li>尝试看名有意义的美剧韩剧日剧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒醉第二段，大年三十除夕夜</title>
      <link href="/2017/01/27/jiu-zui-di-er-duan-da-nian-san-shi-chu-xi-ye/"/>
      <url>/2017/01/27/jiu-zui-di-er-duan-da-nian-san-shi-chu-xi-ye/</url>
      
        <content type="html"><![CDATA[<p>这是第二次喝醉了。威力比上一次提高了许多，因为这酒产生了二段伤害。很要命的，模模糊糊。以为自己不会喝醉， 但还是没计算好心中那竿尺子。<br>今年的酒来的晚，喝的急醉的快，中午还喝了一杯葡萄酒，整个人都感觉飘起来了，去外婆家时也已经做好了喝酒的准备，但真的没想到会喝醉，更没有想到会喝的这么狼狈，真的是人生第一次。</p><hr><p>第一段伤害发生在昨天晚上，吐了一地，还到水沟洗了一下脚。喝酒时劝别人少喝，自己却一个劲的灌。并不是贪杯，想酒喝，好久没喝酒，只是心中<br>对亲情的体会更加深刻，更是出门在外对家的想念。回来的路上，轻飘飘的，很凉，脑袋很模糊也很清晰，模糊是眼前的景象，清晰的是今年的转变。回到家一片懵，倒床就睡，一觉天亮。</p><hr><p>第二段伤害来自于今早，五点就被尿给憋醒了。衣服也没有，冷到了骨子里，头还很晕啊。这次的伤害真的很大啊，走路都感觉天翻地转。这种感觉很痛苦，打死也不想再经历一次。自己家酿的葡萄酒，舅舅家的老舅，啤酒。回头一看，自己都经历了什么酒。清醇的葡萄酒，后劲堪比白酒，却没有白酒伤人，家里的老酒，入口涩涩，却很温热，后劲也挺大。说到底还是自己的酒量不行啊，喝的不多，人却醉了。</p><hr><p>人活着就该想点事，不知什么时候开始，我也会慢慢的打算，把自己的未来过好。我也会慢慢的规划，让自己的未来更加精彩。我也会有脾气了，也更加懂得理的重要性。我知道失去其实也是一种获得，拥有就要珍惜。吃一了堑，就要长一智，2016牺牲了收获了，哭了也笑了。</p><hr><p>2019年3月回笔，经历过一些人生的大起大落之后，我已经把酒劲戒了。不管有什么应酬，不管关系多好，只喝一瓶。酒喝多了伤肝，伤脑，酒后容易吐真言，但有些话只能憋在心里。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 叙事 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个冬天，你在哪里</title>
      <link href="/2017/01/15/zhe-ge-dong-tian-ni-zai-na-li/"/>
      <url>/2017/01/15/zhe-ge-dong-tian-ni-zai-na-li/</url>
      
        <content type="html"><![CDATA[<p>没想到离开深圳会是这样的一种方式，火急火燎的离开公司，急急忙忙的上车，很仓促，但也很幸运和激动，因为终于可以回家了。</p><p>今天冬天不同以往，因为以前回家我都能抢到票的，但今年没有。好像今年的火车票故意躲着我一样，从一个月的预售期初开始买，买到今天愣是一张没买到。这个冬天，真的一票难求。</p><p>票没买到，但家还是得回。在同事的帮助下，最后找到了我大牛哥，大牛哥真的厉害，昨天跟他联系今天就给我买到票。但是，开车前两个小时买到票是什么鬼，还是深圳东，这根本不给人活路啊！于是我便开始了2016狂奔结尾曲，经历了1个多小时的飞奔，最后终于安全上车。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 叙事 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之提高Gradle的编译速度总结</title>
      <link href="/2016/11/08/kai-fa-ji-lu-zhi-ti-gao-gradle-de-bian-yi-su-du-zong-jie/"/>
      <url>/2016/11/08/kai-fa-ji-lu-zhi-ti-gao-gradle-de-bian-yi-su-du-zong-jie/</url>
      
        <content type="html"><![CDATA[<hr><p>刚进公司，由于公司准备新地方，所以电脑不够用，先用自己的电脑开发。然后配置环境，运行项目，由于项目经过多年多人之手迭代，已经残破不堪，<br>所以第一次运行大概花了20多分钟，等得蛋都碎了一地。以为接下来会快一些，鬼知道第二次还是10多分钟，我直接疯掉。</p><p>受不了这种等待，立刻就去求助度娘，最后看了许多关于Gradle优化的资料，编译终于快了许多。后面经过多方尝试之后，<br>发现是Google的run instance的问题，只要开着它运行就特慢，关掉后编译速度杠杠的，原因未知。</p><p>除了Gradle编译外，还发现了另一种增量编译的工具，就是阿里蚂蚁团队打造的FreeLine，<br>使用后发现确实很不错，速度很快，但是由于不够成熟，还是有很多问题，比如不能Debug等等，算了还是安心用Gradle吧。</p><p>以下是总结的笔记，分享给大家。</p><a id="more"></a>  <h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://my.oschina.net/u/1034530/blog/490974" target="_blank" rel="noopener">Android Studio Gradle太慢 解决方案</a></p><p><a href="http://mdsa.51cto.com/art/201503/469038.htm" target="_blank" rel="noopener">30秒让你加速Android Studio/Gradle构建</a></p><p><a href="http://blog.isming.me/2015/03/18/android-build-speed-up/" target="_blank" rel="noopener">加速Android Studio/Gradle构建</a></p><h3 id="参考步骤"><a href="#参考步骤" class="headerlink" title="参考步骤"></a>参考步骤</h3><h4 id="第一步：配置-gradle文件夹目录（开启Gradle单独守护线程）"><a href="#第一步：配置-gradle文件夹目录（开启Gradle单独守护线程）" class="headerlink" title="第一步：配置.gradle文件夹目录（开启Gradle单独守护线程）"></a>第一步：配置.gradle文件夹目录（开启Gradle单独守护线程）</h4><p>在windows系统的C:\Users\用户名\.gradle目录下创建gradle.properties文件（有直接用），然后添加以下内容，添加之后会在所以的项目中生效（有内容则并入），添加后全局生效</p><pre><code>    org.gradle.daemon=true  // 开启线程守护，第一次编译时开线程，之后就不会再开了    org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8  // 配置编译时的虚拟机大小    org.gradle.parallel=true  // 开启并行编译，相当于多条线程再走    org.gradle.configureondemand=true   启用新的孵化模式</code></pre><p>还可以在当前项目中的gradle.properties文件中添加以上内容，则只会在当前项目生效</p><h4 id="第二步：修改android-studio配置"><a href="#第二步：修改android-studio配置" class="headerlink" title="第二步：修改android studio配置"></a>第二步：修改android studio配置</h4><p>Ctrl+Alt+S打开设置选项卡，找到Gradle选项，选中offline work，点击apply，如下<br><img src="http://upload-images.jianshu.io/upload_images/2786991-f3f4af2c423b914b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gradle选项配置"></p><p>找到Compiler选项，设置如下<br><img src="http://upload-images.jianshu.io/upload_images/2786991-ca9457f2b9bd0711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="compiler选项配置"></p><p>设置网络代理，增加访问网络速度，具体请参考提供的网站</p><p>在具体开发module的build.gradle文件中添加</p><pre><code>    dexOptions {        //使用增量模式构建        incremental true        //最大堆内存        javaMaxHeapSize &quot;8g&quot;        // 上面两项在As2.2后可以去掉了，默认支持        //是否支持大工程模式        jumboMode = true        //预编译        preDexLibraries = true        //线程数        threadCount = 8    }</code></pre><hr><h2 id="另一种神速编译方式，使用命令行脚本的方式编译"><a href="#另一种神速编译方式，使用命令行脚本的方式编译" class="headerlink" title="另一种神速编译方式，使用命令行脚本的方式编译"></a>另一种神速编译方式，使用命令行脚本的方式编译</h2><p>第一步：在目标项目的根节点下创建文件c.bat（名字尽量短） –&gt; 构建脚本，内容如下：</p><pre><code>    @Echo Off    if /i &quot;%1&quot;==&quot;&quot; goto :default    if /i &quot;%1&quot;==&quot;i&quot; goto :install    if /i &quot;%1&quot;==&quot;u&quot; goto :uninstall    ::执行实际的命令    goto :raw    ::无参数情况下的默认执行命令    :default    gradlew iD    goto :eof    ::实际命令    :raw    gradlew %1    goto :eof    ::安装所有Debug版本的APK    :install    gradlew iD    goto :eof    ::卸载所有版本的APK    :uninstall    gradlew uA    goto :eof</code></pre><p>第二步：在AS控制台的命令行Terminal窗口输入刚才的文件名，然后回车就好了，编译成功，然后打开应用</p><p>这种方式好像是会更快一些，而且不会导入整个电脑的卡顿，总的来说这种方法可以值得推荐，但是使用起来也不是特别的方便。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多方尝试后发现，只要使用run instance之后，第一次编译就变得特别的慢，至少都要3分钟，还有特别卡顿，卡的电脑动都动不了，但是在去掉即时运行后，编译时间就短了很多，只有30秒，而且一点都不卡，最后毅然改成了普通运行。</p><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
            <tag> 2016 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发记录之自定义无限自动轮播的Banner控件</title>
      <link href="/2016/11/07/kai-fa-ji-lu-zhi-zi-ding-yi-wu-xian-zi-dong-lun-bo-de-banner-kong-jian/"/>
      <url>/2016/11/07/kai-fa-ji-lu-zhi-zi-ding-yi-wu-xian-zi-dong-lun-bo-de-banner-kong-jian/</url>
      
        <content type="html"><![CDATA[<hr><p>显示的效果请往下看，先说一下需求，可以自动轮播，按下停止轮播，松手开始轮播，不可见时停止轮播，自动轮播时带动画，手动滑动时不带动画，<br>点击时要有水波纹效果，下拉刷新回到第一页，页面不能卡顿等等。参考了一些网上的想法，结合自己的认知，总结如下。</p><a id="more"></a><h4 id="先上效果图"><a href="#先上效果图" class="headerlink" title="先上效果图"></a>先上效果图</h4><p><img width="40%" height="80%" src="http://upload-images.jianshu.io/upload_images/2786991-34861ad3cdcb4231.gif?imageMogr2/auto-orient/strip"></p><h4 id="自定BannerView控件"><a href="#自定BannerView控件" class="headerlink" title="自定BannerView控件"></a>自定BannerView控件</h4><p>为了以后开发的方便，这里将Banner封装成一个控件来使用，以后就可以直接在布局里引用。</p><p>做这种轮播效果一般采用的都是<code>ViewPager</code>，所以这个控件也是对<code>ViewPager</code>的封装，为了解耦，这里没有把适配器放在<code>BannerView</code>，只是提供了基类适配器和接口，使用很方便。</p><p>讲一下具体如何实现封装：<br>第一步：自定义控件，实现构造，初始化属性和视图。</p><ul><li>基于需求，先定义了页面边距，主页面占比，缩放比例，轮播时长，是否动画轮播等等属性，通过引用attrs的方式，在布局里赋值，并且提供set方法在代码里设置。</li></ul><pre><code>private void initAttrs(Context context, AttributeSet attrs) {        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.BannerView);        pageMargin = (int) a.getDimension(R.styleable.BannerView_bannerPageMargin, pageMargin);        pagePercent = a.getFloat(R.styleable.BannerView_bannerPagePercent, pagePercent);        scaleMin = a.getFloat(R.styleable.BannerView_bannerPageScale, scaleMin);        alphaMin = a.getFloat(R.styleable.BannerView_bannerPageAlpha, alphaMin);        ...        a.recycle();    }</code></pre><ul><li>定义了基本属性后，将<code>ViewPager</code>视图填充到控件容器里，ViewPager布局里需要使用<code>clipChildren</code>属性来控制系统绘制View的范围，在<code>ViewPager</code>和它的父容器里都设置<code>clipChildren=false</code>。这样指定了主页面占比后，左右两边的Page就会进行绘制。</li></ul><pre><code>    private void initView() {        mRootView = LayoutInflater.from(getContext()).inflate(R.layout.banner_view, this);        mViewPager = (ViewPager) mRootView.findViewById(R.id.viewPager);        LayoutParams params = (LayoutParams) mViewPager.getLayoutParams();        params.width = (int) (getScreenWidth() * pagePercent);        params.gravity = Gravity.CENTER;        mViewPager.setLayoutParams(params);        mViewPager.setPageMargin(pageMargin);        mViewPager.setPageTransformer(false, new BannerPageTransformer());        mViewPager.setOffscreenPageLimit(5);        // 自动轮播任务        mScrollTask = new AutoScrollTask();        // 如果动画轮播        if (isAnimScroll) {            setAnimationScroll((int) mAnimDuration);        }    }</code></pre><hr><p>第二步：滑动动画实现</p><ul><li><p>众所周知，谷歌已经提供了<code>ViewPager</code>的滑动动画设置接口<code>setPageTransformer()</code>，并且他自己也实现了三种基本的滑动滑动。需要自定义动画时只需实现<code>ViewPager.PageTransformer</code>接口，并实现<code>transformPage()</code>方法。</p></li><li><p>设计稿中的动画要求是，滑动时左侧缩小，主页随着滑动百分比缩小，右侧随着滑动百分比放大。<code>transformPage</code>方法中提供了主页所在的<code>position=0.0</code>，左侧位置百分比<code>position&lt;0</code>，右侧位置百分比<code>position&gt;0</code>，通过这个position可以动态计算出各个页面的缩放比。</p></li></ul><pre><code>    public void transformPage(View page, float position) {       // 不同位置的缩放和透明度       float scale = (position &lt; 0)                ? ((1 - scaleMin) * position + 1)                : ((scaleMin - 1) * position + 1);       float alpha = (position &lt; 0)                ? ((1 - alphaMin) * position + 1)                : ((alphaMin - 1) * position + 1);       // 保持左右两边的图片位置中心       if (position &lt; 0) {            ViewCompat.setPivotX(page, page.getWidth());            ViewCompat.setPivotY(page, page.getHeight() / 2);        } else {            ViewCompat.setPivotX(page, 0);            ViewCompat.setPivotY(page, page.getHeight() / 2);        }        Log.d(TAG, &quot;transformPage: scale=&quot; + scale);        ViewCompat.setScaleX(page, scale);        ViewCompat.setScaleY(page, scale);        ViewCompat.setAlpha(page, Math.abs(alpha));    }</code></pre><p>第三步：无限自动轮播和轮播动画处理</p><ul><li>无限轮播可用线程池，定时器，<code>Handler</code>等等实现，这里采用最简单的Handler实现。首先自定义一个轮播任务，实现Runnable接口，在run方法里使用Handler发送延时消息来不停轮播，并且提供start方法和stop方法开启和停止轮播。在初始化视图完毕时，开启轮播。</li></ul><pre><code>   @Override    protected void onAttachedToWindow() {        super.onAttachedToWindow();        // 视图初始化完毕，开始轮播任务        if (mScrollTask == null) mScrollTask = new AutoScrollTask();        if (isAutoScroll) startAutoScroll();    }</code></pre><ul><li><code>ViewPager</code>滑动是没有延时的，谷歌也没有提供具体的接口去实现延时滑动。所以这里使用反射去重新设置<code>ViewPager</code>的滑动世间。自动轮播时，需求动画延时滑动，但是手动滑动时需要原生的滑动，所以根据使用时间差和滑动时间来控制自动和手动滑动。</li></ul><pre><code> public void startScroll(int startX, int startY, int dx,                                        int dy, int duration) {      // 如果手动滚动,则加速滚动         // TODO 使用这种设置极不稳定，需要抽离         if (System.currentTimeMillis() - mRecentTouchTime &gt; mScrollDuration &amp;&amp; isAnimScroll) {             // 动画滑动             duration = during;         } else {             // 手势滚动             duration /= 2;         }         super.startScroll(startX, startY, dx, dy, duration);     }</code></pre><hr><h4 id="BannerView的基类适配器封装"><a href="#BannerView的基类适配器封装" class="headerlink" title="BannerView的基类适配器封装"></a>BannerView的基类适配器封装</h4><ul><li><code>BannerView</code>封装的是<code>ViewPager</code>，所以基类适配器<code>BannerBaseAdapter</code>封装的也是<code>PagerAdapter</code>，由于适配器涉及到数据和视图，所以基类里将所有都封装好，只留数据和视图留给子类去实现。除此之外，页面的点击，按下和抬起也在适配器实现并通过接口暴露出来。</li><li>实现父类适配后，只需要指定数据类型和实现展示视图转换数据的方法，加载完数据之后，通过setData方法来重新更新数据即可。</li></ul><pre><code>private class BannerAdapter extends BannerBaseAdapter&lt;BannerBean&gt; {        public BannerAdapter(Context context) {            super(context);        }        @Override        protected int getLayoutResID() {            return R.layout.item_banner;        }        @Override        protected void convert(View convertView, BannerBean data) {            setImage(R.id.pageImage, data.imageRes);            setText(R.id.pageText, data.title);        }  }</code></pre><h4 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h4><ul><li>拷贝BannerView全路径到布局里，使用attrs指定属性</li></ul><pre><code>&lt;com.pinger.widget.banner.BannerView      android:id=&quot;@+id/bannerView&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;200dp&quot;      app:bannerPageAlpha=&quot;1.0&quot;      app:bannerPageMargin=&quot;8dp&quot;      app:bannerPagePercent=&quot;0.8&quot;      app:bannerPageScale=&quot;0.8&quot;      app:bannerAnimScroll=&quot;true&quot;      app:bannerAutoScroll=&quot;true&quot;      app:bannerScrollDuration=&quot;4000&quot;      app:bannerAnimDuration=&quot;1500&quot;/&gt;</code></pre><ul><li>在代码中设置适配器和设置页面的触摸监听，初始化数据之后，更新数据</li></ul><pre><code>  final BannerView bannerView = (BannerView) findViewById(R.id.bannerView);  bannerView.setAdapter(mAdapter = new BannerAdapter(this));  initData();  // 初始化数据  mAdapter.setData(mDatas);  mAdapter.setOnPageTouchListener(...);</code></pre><hr><p><a href="https://github.com/PingerOne/android_develop_sample/blob/master/android_widget/src/main/java/com/pinger/widget/banner/BannerView.java" target="_blank" rel="noopener">Demo下载地址</a></p><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Android </tag>
            
            <tag> 2016 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
