<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>万合天宜</title>
  
  <subtitle>一个人的朝圣</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pingerx.com/"/>
  <updated>2019-12-13T14:10:22.612Z</updated>
  <id>https://pingerx.com/</id>
  
  <author>
    <name>Pinger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不成疯便成魔</title>
    <link href="https://pingerx.com/2019/12/13/bu-cheng-feng-bian-cheng-mo/"/>
    <id>https://pingerx.com/2019/12/13/bu-cheng-feng-bian-cheng-mo/</id>
    <published>2019-12-12T16:00:00.000Z</published>
    <updated>2019-12-13T14:10:22.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态天音"><a href="#动态天音" class="headerlink" title="动态天音"></a>动态天音</h3><ul><li>无期-石白其</li><li>中毒-光贼</li><li>桥下-谢春花</li><li>神秘嘉宾，别让我走远-林宥嘉</li><li>有可能的夜晚-颜人中</li></ul><h3 id="KTV必点歌曲"><a href="#KTV必点歌曲" class="headerlink" title="KTV必点歌曲"></a>KTV必点歌曲</h3><ul><li>慢慢-张学友</li><li>约定-陈奕迅</li><li>孤独患者-陈奕迅</li><li>冷雨夜-Bybond</li><li>意外-薛之谦</li><li>绅士-薛之谦</li><li>空白格-杨宗纬</li><li>唯一-王力宏</li><li>你最珍贵-张学友</li><li>等不到得爱-樊凡</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动态天音&quot;&gt;&lt;a href=&quot;#动态天音&quot; class=&quot;headerlink&quot; title=&quot;动态天音&quot;&gt;&lt;/a&gt;动态天音&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;无期-石白其&lt;/li&gt;
&lt;li&gt;中毒-光贼&lt;/li&gt;
&lt;li&gt;桥下-谢春花&lt;/li&gt;
&lt;li&gt;神秘嘉宾，别让我走
      
    
    </summary>
    
      <category term="生活" scheme="https://pingerx.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="2019" scheme="https://pingerx.com/tags/2019/"/>
    
      <category term="叙事" scheme="https://pingerx.com/tags/%E5%8F%99%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何在星巴克愉快的使用英文点餐</title>
    <link href="https://pingerx.com/2019/03/04/ru-he-zai-xing-ba-ke-yu-kuai-de-shi-yong-ying-wen-dian-can/"/>
    <id>https://pingerx.com/2019/03/04/ru-he-zai-xing-ba-ke-yu-kuai-de-shi-yong-ying-wen-dian-can/</id>
    <published>2019-03-03T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.174Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候衡量一个人英语口语好不好，只需要看这个人能不能在星巴克优雅的点一杯咖啡。在星巴克来来回回也点了上百次了，从第一次不知道怎么选和说，到现在闭着眼睛都能背菜单，中间也就差个上百次～</p><p><img src="https://raw.githubusercontent.com/pingerx/pingerx.github.io/hexo/source/images/20190302221623.jpg" alt></p><p>在说星巴克点咖啡之前，我们先来简单介绍一下星巴克。星巴克英文名叫Starbucks，发源地与总部位于美国华盛顿州西雅图，是一家全球最大的连锁咖啡店。实际上星巴克是一个自定义饮品的休闲区，只要你不扰乱秩序，你在里面看书、蹭网、聊天、休息等等都OK，至于你点没点饮料，坐多久，是没人会管的。</p><p>同时，在点餐之前，我们要先了解一下星巴克咖啡的常识。</p><ul><li><p>杯型。星巴克的杯子有三种型号，Tall为中杯，Grande为大杯，Venti为超大杯。男生一般选Grande就够了，女生一般选Tall或者Grande。当然如果你要坐下来慢慢喝，你也可以点Venti杯型，既划算，又可以喝很久。<br><img src="https://raw.githubusercontent.com/pingerx/pingerx.github.io/hexo/source/images/20190302221702.jpg" alt="杯型"></p></li><li><p>温度。热饮：<code>Hot Drink</code>，含冰冷饮：<code>Iced Drink</code>，去冰：<code>No Ice</code>，少冰 ：<code>Easy On Ice</code>。比如我要点一杯热牛奶，就可以说 <code>I want a cup of hot milk</code> 或者直接 <code>hot milk</code> 都是可以的。</p></li><li><p>糖浆。星巴克所有甜的饮品都是放糖浆的。一般有榛果糖浆：Hazelnut Syrup，香草糖浆：Vanilla Syrup，焦糖糖浆：Caramel Syrup。个人点香草的比较多，非常符合我的口味。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有的时候衡量一个人英语口语好不好，只需要看这个人能不能在星巴克优雅的点一杯咖啡。在星巴克来来回回也点了上百次了，从第一次不知道怎么选和说，到现在闭着眼睛都能背菜单，中间也就差个上百次～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserconte
      
    
    </summary>
    
      <category term="生活" scheme="https://pingerx.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="2019" scheme="https://pingerx.com/tags/2019/"/>
    
      <category term="叙事" scheme="https://pingerx.com/tags/%E5%8F%99%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>小米8 lite手机刷机体验</title>
    <link href="https://pingerx.com/2019/03/02/xiao-mi-8-lite-shou-ji-shua-ji-ti-yan/"/>
    <id>https://pingerx.com/2019/03/02/xiao-mi-8-lite-shou-ji-shua-ji-ti-yan/</id>
    <published>2019-03-01T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.174Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用小米8手机，发现miui系统还是挺不错的，但是有一个很致命的缺点，就是广告太多了，而且不能安装谷歌服务。<br>miui系统除了有国内的版本，还有全球版。全球版内置了谷歌服务，并且没有广告，使用起来也是爽歪歪。</p><h4 id="所以毫不犹豫，选择刷机。"><a href="#所以毫不犹豫，选择刷机。" class="headerlink" title="所以毫不犹豫，选择刷机。"></a>所以毫不犹豫，选择刷机。</h4><p>在网上找了下刷机的教程，知乎有个专题专门提供全球版刷机解决方案，按照里面的流程刷了一次，直接成功。</p><p><a href="https://www.zhihu.com/question/50231539" target="_blank" rel="noopener">知乎专题</a></p><p>刷机分为两种，一种是将rom包放到手机里，在手机的升级界面选择rom包进行升级刷机。一种是使用线刷工具，将rom包刷进手机。两种方式都是非常的简单。</p><p><a href="http://en.miui.com/a-232.html" target="_blank" rel="noopener">刷机教程</a></p><p>写完了这段文字，手机也刚刷好~ 又可以继续愉快的玩耍了。</p><hr><p>2月6号，突然发现，之前刷的那个国际版本部分页面还是有谷歌的广告，蛋疼。<br>知乎上有个回答是使用欧盟官方分销商ABC Data认可的MIUI系统。<a href="https://xiaomi.eu/community/" target="_blank" rel="noopener">xiaomi.eu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近使用小米8手机，发现miui系统还是挺不错的，但是有一个很致命的缺点，就是广告太多了，而且不能安装谷歌服务。&lt;br&gt;miui系统除了有国内的版本，还有全球版。全球版内置了谷歌服务，并且没有广告，使用起来也是爽歪歪。&lt;/p&gt;
&lt;h4 id=&quot;所以毫不犹豫，选择刷机。&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="生活" scheme="https://pingerx.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="2019" scheme="https://pingerx.com/tags/2019/"/>
    
      <category term="叙事" scheme="https://pingerx.com/tags/%E5%8F%99%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android使用Jenkins持续集成</title>
    <link href="https://pingerx.com/2018/07/23/android-shi-yong-jenkins-chi-xu-ji-cheng/"/>
    <id>https://pingerx.com/2018/07/23/android-shi-yong-jenkins-chi-xu-ji-cheng/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>平时迭代开发需要频繁的打包发布到蒲公英上，重复的操作总是令人厌烦。这里简单介绍一下，使用Jenkins自动打包发布到蒲公英上。</p></blockquote><h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><ul><li>下载最新的版本（一个 WAR 文件）。<a href="https://jenkins.io" target="_blank" rel="noopener">官网下载地址</a></li><li>运行 <code>java -jar jenkins.war</code> 注意：Jenkins 需要运行 Java 5以及以上的版本。</li></ul><a id="more"></a><h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><ul><li>第一次启动，复制命令行中的密码，打开浏览器，输入<code>localhost:8080</code>，输入密码，进入主页，创建用户。</li><li>点击 <code>系统管理-&gt;管理插件-&gt;可选插件</code>，可搜索以下插件安装(其他插件按需安装)。<ul><li>git插件(GIT plugin)</li><li>ssh插件(SSH Credentials Plugin)</li><li>Gradle插件(Gradle plugin)</li></ul></li><li>点击 <code>系统管理-&gt;系统设置-&gt;全局属性</code>，添加以下键值对，要和系统环境一样。<ul><li>ANDROID_HOME</li><li>GRADLE_HOME</li><li>JAVA_HOME</li></ul></li></ul><p><img src="http://chuantu.biz/t6/347/1532335531x-1566688556.jpg" alt="全局属性"></p><ul><li>点击 <code>系统管理-&gt;全局工具配置</code>,Git设置为自动安装，Gradle设置为GRADLE_HOME的路径（路径对上就没问题）。</li></ul><p><img src="http://chuantu.biz/t6/347/1532335501x-1566688556.jpg" alt="全局工具配置"></p><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><ul><li><p>点击新建任务，选择构建一个自由风格的软件项目</p></li><li><p>源码管理，配置Git的仓库</p><ul><li>Repository URL：仓库地址</li><li>Credentials：账号密码</li><li>Branch Specifier：构建分支</li></ul></li><li><p>构建触发器</p><ul><li>定时构建：<code>H/60 * * * *</code>表示60分钟检查一次代码，有更新就构建</li></ul></li></ul><p><img src="http://chuantu.biz/t6/347/1532335446x-1566688556.jpg" alt="仓库和触发器"></p><ul><li>构建(主要配置Use Gradle Wrapper)<ul><li>Make gradlew executable，打钩</li><li>Tasks：<code>build</code>或者是具体的任务<code>:app:assembleRelease</code></li><li>Root Build script：<code>${workspace}</code></li><li>Build File：<code>${workspace}/a8sport/build.gradle</code></li></ul></li></ul><p><img src="http://chuantu.biz/t6/347/1532335583x-1566688556.jpg" alt="构建"></p><h3 id="构建任务"><a href="#构建任务" class="headerlink" title="构建任务"></a>构建任务</h3><ul><li>点击立即构建，就可以主动构建任务，第一次会从Git服务器拉取代码，可能会有一些问题会构建失败，前几次失败了再构建就好，如果一直失败可能就是配置有问题，看一下控制台输出。</li><li>构建输出目录，点击<code>系统管理-&gt;系统设置</code>可以查看Jenkins的根目录，在根目录下的workspace下有构建的任务，如<code>app/build/outputs/apk/beta/release</code></li></ul><h3 id="发布到蒲公英"><a href="#发布到蒲公英" class="headerlink" title="发布到蒲公英"></a>发布到蒲公英</h3><ul><li>安装插件<code>Upload to pgyer</code></li><li>配置任务，在构建后操作中，选择<code>upload to pgyer with apiV2</code>，配置相关参数即可</li></ul><p><img src="http://chuantu.biz/t6/347/1532335554x-1566688556.jpg" alt="上传蒲公英"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.pgyer.com/doc/view/jenkins" target="_blank" rel="noopener">蒲公英文档</a></li><li><a href="https://blog.csdn.net/u011541946/article/details/78267097" target="_blank" rel="noopener">Android基于Gradle参数化打不同环境安装包</a></li></ul><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;平时迭代开发需要频繁的打包发布到蒲公英上，重复的操作总是令人厌烦。这里简单介绍一下，使用Jenkins自动打包发布到蒲公英上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装Jenkins&quot;&gt;&lt;a href=&quot;#安装Jenkins&quot; class=&quot;headerlink&quot; title=&quot;安装Jenkins&quot;&gt;&lt;/a&gt;安装Jenkins&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;下载最新的版本（一个 WAR 文件）。&lt;a href=&quot;https://jenkins.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;java -jar jenkins.war&lt;/code&gt; 注意：Jenkins 需要运行 Java 5以及以上的版本。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="2018" scheme="https://pingerx.com/tags/2018/"/>
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="https://pingerx.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件权限</title>
    <link href="https://pingerx.com/2018/07/03/linux-wen-jian-quan-xian/"/>
    <id>https://pingerx.com/2018/07/03/linux-wen-jian-quan-xian/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.173Z</updated>
    
    <content type="html"><![CDATA[<p>有一次下载一个工具，点击setup时没有反应，使用命令行打开时提示权限不够。<br>Linux系统对文件的权限做了很详细的区分和敏感处理，因此需要单独去申请权限。<br>常用的命令如下。</p><a id="more"></a>  <h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>列举当前目录文件权限: <code>ls -l</code></li><li>当前目录指定文件权限：<code>chmod a+x filename</code></li><li>指定目录文件权限:<code>chmod 777 /home/pinger</code></li><li>指定目录及该目录下的子目录和子文件的权限:<code>chmod -R 777 /home/pinger</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一次下载一个工具，点击setup时没有反应，使用命令行打开时提示权限不够。&lt;br&gt;Linux系统对文件的权限做了很详细的区分和敏感处理，因此需要单独去申请权限。&lt;br&gt;常用的命令如下。&lt;/p&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="2018" scheme="https://pingerx.com/tags/2018/"/>
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Linux" scheme="https://pingerx.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用Github来管理Hexo博客文件</title>
    <link href="https://pingerx.com/2018/07/03/shi-yong-github-lai-guan-li-hexo-bo-ke-wen-jian/"/>
    <id>https://pingerx.com/2018/07/03/shi-yong-github-lai-guan-li-hexo-bo-ke-wen-jian/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.174Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo在本地完成初始化和博客编辑，最终是部署在Github上的。<br>如果你换台电脑更新博客就非常麻烦，必须要拷贝博客的代码，重新部署才能生效。<br>有一个办法可以解决这个问题，就是在Github上开一个分之来管理代码文件。</p><a id="more"></a>  <p>Hexo部署在Github上默认是master分支，这个分支是<br>存放Hexo部署后的文件的，并不是本地博客的源文件。</p><p>使用命令<code>git branch hexo</code>新建hexo分支，该将作为存放本地源文件的分支。<br>在master分支上编辑文件，部署发布博客，等博客发布完成后，执行<code>git add .</code><br>和<code>git commit -m &#39;更新内容&#39;</code>把改动的文件添加到本地git仓库。</p><p>执行<code>git checkout hexo</code>，切换到hexo分支，该分支不需要改动任何内容。<br>在hexo分支上执行<code>git merge master</code>合并master分支的文件，<br>执行<code>git push hexo</code>发布到服务器就好了。</p><p>当换台电脑编写博客时，如果是第一次使用，先拉取Github上的代码到本地，配置好Hexo的环境。<br>执行<code>git branch</code>确定当前在哪个分支，如果不在hexo分支，<br>则执行<code>git checkout hexo</code>切换到hexo分支，执行<code>git pull</code>拉取服务器的最新文件。</p><p>切换回master分支，执行<code>git merge hexo</code>，合并hexo分支来拉取最新的源文件，<br>这样就保证了换电脑了，本地的master分支接上了上一次更新的master分支内容。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>master分支用来编辑内容，该分支的文件不需要使用git提交到服务器，而是使用hexo命令部署。</li><li>hexo分支不需要编辑内容，该分支是master分支文件的中转，需要使用git进行提交和拉取。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo在本地完成初始化和博客编辑，最终是部署在Github上的。&lt;br&gt;如果你换台电脑更新博客就非常麻烦，必须要拷贝博客的代码，重新部署才能生效。&lt;br&gt;有一个办法可以解决这个问题，就是在Github上开一个分之来管理代码文件。&lt;/p&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="2018" scheme="https://pingerx.com/tags/2018/"/>
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Git" scheme="https://pingerx.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio添加ShadowSockets代理</title>
    <link href="https://pingerx.com/2018/05/12/androidstudio-tian-jia-shadowsockets-dai-li/"/>
    <id>https://pingerx.com/2018/05/12/androidstudio-tian-jia-shadowsockets-dai-li/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.171Z</updated>
    
    <content type="html"><![CDATA[<ul><li>平时使用Android Studio访问的基本都是国外的服务器，网速十分的缓慢。所以一般都会对Studio设置代理，<br>可以直接翻墙访问，速度也是蹭蹭蹭往上涨。</li><li>进入Studio设置界面，搜索proxy，选择http proxy选项。</li><li>选择Automatic proxy configuration url，填入<code>http://127.0.0.1:1080/pac</code>，apply就可以了。</li></ul><a id="more"></a>  <blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;平时使用Android Studio访问的基本都是国外的服务器，网速十分的缓慢。所以一般都会对Studio设置代理，&lt;br&gt;可以直接翻墙访问，速度也是蹭蹭蹭往上涨。&lt;/li&gt;
&lt;li&gt;进入Studio设置界面，搜索proxy，选择http proxy选项。&lt;/li&gt;
&lt;li&gt;选择Automatic proxy configuration url，填入&lt;code&gt;http://127.0.0.1:1080/pac&lt;/code&gt;，apply就可以了。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="2018" scheme="https://pingerx.com/tags/2018/"/>
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="https://pingerx.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>一路向南，过我的生活</title>
    <link href="https://pingerx.com/2018/04/15/yi-lu-xiang-nan-guo-wo-de-sheng-huo/"/>
    <id>https://pingerx.com/2018/04/15/yi-lu-xiang-nan-guo-wo-de-sheng-huo/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.173Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=526472371&auto=0&height=66"></iframe><hr><p>选择学校,一路向北。离开学校，一路向南。</p><p>北方的第一年生活真的不太适应，走在路上都觉得别扭，<br>尤其听着导员的东北口音，感觉自己在炼狱里。<br>逃课应该是从大二开始吧，每天窝在图书馆没日没夜码代码，痛并快乐着。<br>特感谢那一年的我，厚积薄发。<br>大三那年为了考软考高级证书，硬是把２万字的作文背了下来，<br>花了两个学期，拿了两个证书，只是现在并没有用到。</p><p>怀念大学的时光，虽然每天都重复着，<br>但是每天都有不一样的精彩，现在想起来觉得很珍贵。<br>毕业后，大衡和小生在北京做后台，东东在新疆搞大数据，<br>曲博在杭州做后台，承JB在杭州做h5前端，我在深圳做Android开发。</p><a id="more"></a>   <img width="40%" src="http://p6jk8aaz8.bkt.clouddn.com/20180415212044.jpg"><p>刚到深圳时，感觉整个世界只有自己，<br>现在觉得自己很幸运，能遇到好朋友，<br>但也觉得自己很悲哀，不善交际，更没有精力去提高。</p><p>有的时候真的觉得很无聊。<br>所以我一个人去电影院看了《雷神３》和《头号玩家》，<br>电影很不错，而且左右两边都是漂亮妹子。</p><p>很意外，子英居然也在深圳，也很惭愧，我竟一无所知。<br>想起当初离校时的匆忙，也许记得的只有自己吧。</p><p>清明假期，游志勇过来深圳了。<br>据他自己说是先到珠海的东澳岛荒野求生（其实是变天降温刮大风），<br>逃离后来深圳找我们玩的。<br>所以我带了两件外套后，带他到海上世界和欢乐海岸继续吹风。</p><p>我催着子英计划日本旅游，她说年底去，但是我感觉很虚。<br>几个人相聚就差仕进了，他还在南昌上班，<br>他说攒点工作经验就要回去继承家业了。<br>程序猿表示羡慕。</p><img width="40%" src="http://p6jk8aaz8.bkt.clouddn.com/20180415212506.jpg"><p>自己想做很多东西，虽然不一定能做起来，<br>但我还是去注册了一个公司，叫雷播科技。<br>一步一个脚印，只是为了有更丰富的人生。</p><p>没有人会主动迎合普通人，除非你是大神级别，<br>不然你只能去奉承别人。这却是我最讨厌的。<br>我这个人很现实，考虑到的事情基本都是坏的，<br>有时候让我变得很消极，也让我错过了很多的机会。</p><p>像我这样孤僻性格的人，不会讨人喜欢，也没有资格去喜欢别人。</p><p>许久未见，甚是想念，大家都还好吗。</p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=526472371&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;hr&gt;
&lt;p&gt;选择学校,一路向北。离开学校，一路向南。&lt;/p&gt;
&lt;p&gt;北方的第一年生活真的不太适应，走在路上都觉得别扭，&lt;br&gt;尤其听着导员的东北口音，感觉自己在炼狱里。&lt;br&gt;逃课应该是从大二开始吧，每天窝在图书馆没日没夜码代码，痛并快乐着。&lt;br&gt;特感谢那一年的我，厚积薄发。&lt;br&gt;大三那年为了考软考高级证书，硬是把２万字的作文背了下来，&lt;br&gt;花了两个学期，拿了两个证书，只是现在并没有用到。&lt;/p&gt;
&lt;p&gt;怀念大学的时光，虽然每天都重复着，&lt;br&gt;但是每天都有不一样的精彩，现在想起来觉得很珍贵。&lt;br&gt;毕业后，大衡和小生在北京做后台，东东在新疆搞大数据，&lt;br&gt;曲博在杭州做后台，承JB在杭州做h5前端，我在深圳做Android开发。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://pingerx.com/categories/life/"/>
    
    
      <category term="2018" scheme="https://pingerx.com/tags/2018/"/>
    
      <category term="生活" scheme="https://pingerx.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="旧事" scheme="https://pingerx.com/tags/%E6%97%A7%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux制作快捷启动方式</title>
    <link href="https://pingerx.com/2018/04/10/linux-zhi-zuo-kuai-jie-qi-dong-fang-shi/"/>
    <id>https://pingerx.com/2018/04/10/linux-zhi-zuo-kuai-jie-qi-dong-fang-shi/</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.173Z</updated>
    
    <content type="html"><![CDATA[<p>Linux使用的安装程序是.deb后缀的软件，安装这种软件会自动生成启动图标，但是我们自己解压出来的.sh文件<br>就不能够生成快捷启动方式，所以需要制作启动方法。</p><h4 id="Linux默认启动图标位置"><a href="#Linux默认启动图标位置" class="headerlink" title="Linux默认启动图标位置"></a>Linux默认启动图标位置</h4><ul><li>Linux默认的启动图标都在<code>/usr/share/applications</code>这个目录里，使用txt编辑器打开这些文件，发现<br>其实是键值对的文本内容，并且文件的后缀都是<code>.desktop</code>。</li></ul><pre><code>  [Desktop Entry]  Name=studio  Comment=this is Android Studio  Exec=/home/pinger/Develop/Android/android-studio/bin/studio.sh  Icon=/home/pinger/Develop/Android/android-studio/bin/studio.png  Terminal=false  Type=Application  Categories=Application;</code></pre><a id="more"></a>  <ul><li>其中<ul><li>Name表示启动应用的名字</li><li>Exec表示启动程序的入口，要填写完整</li><li>Icon表示启动应用的图标</li></ul></li></ul><h4 id="制作启动图标"><a href="#制作启动图标" class="headerlink" title="制作启动图标"></a>制作启动图标</h4><ul><li>打开文件管理器，进入desktop目录，新建文本文件，将上面内容复制进入，替换Name，Exec和Icon的值，保存关闭。</li><li>修改该文件名为Name的值，后缀为.desktop。确认即可启动该应用。  </li></ul><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux使用的安装程序是.deb后缀的软件，安装这种软件会自动生成启动图标，但是我们自己解压出来的.sh文件&lt;br&gt;就不能够生成快捷启动方式，所以需要制作启动方法。&lt;/p&gt;
&lt;h4 id=&quot;Linux默认启动图标位置&quot;&gt;&lt;a href=&quot;#Linux默认启动图标位置&quot; class=&quot;headerlink&quot; title=&quot;Linux默认启动图标位置&quot;&gt;&lt;/a&gt;Linux默认启动图标位置&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux默认的启动图标都在&lt;code&gt;/usr/share/applications&lt;/code&gt;这个目录里，使用txt编辑器打开这些文件，发现&lt;br&gt;其实是键值对的文本内容，并且文件的后缀都是&lt;code&gt;.desktop&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  [Desktop Entry]
  Name=studio
  Comment=this is Android Studio
  Exec=/home/pinger/Develop/Android/android-studio/bin/studio.sh
  Icon=/home/pinger/Develop/Android/android-studio/bin/studio.png
  Terminal=false
  Type=Application
  Categories=Application;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="2018" scheme="https://pingerx.com/tags/2018/"/>
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Linux" scheme="https://pingerx.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下使用Genymotion-ARM架构的模拟器</title>
    <link href="https://pingerx.com/2018/04/02/linux-xia-shi-yong-genymotion-arm-jia-gou-de-mo-ni-qi/"/>
    <id>https://pingerx.com/2018/04/02/linux-xia-shi-yong-genymotion-arm-jia-gou-de-mo-ni-qi/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<code>deeplin</code>的<code>Linux</code>系统上使用<code>Genymotion</code>安装程序时，提示<code>Installation error: INSTALL_FAILED_NO_MATCHING_ABIS</code>，<br>意思是没有匹配的架构。Genymotion模拟器使用的是<code>x86</code>架构，所以<code>ARM</code>架构的程序安装不了。<br>解决办法就是给模拟器安装一个<code>ARM</code>架构的转换包。</p></blockquote><ul><li>打开模拟器，可以正常运行，将下载的转换包拖进模拟器，会提示安装，点击安装。</li><li>安装成功后，打开命令行，输入<code>adb shell /system/etc/houdini_patcher.sh</code>。</li><li>重新打开模拟器，再次运行程序，成功安装。<br><a href="https://blog.csdn.net/qq_30707799/article/details/68927892" target="_blank" rel="noopener">参考地址</a><br><a href="http://p6jk8aaz8.bkt.clouddn.com/Genymotion-ARM-Translation.zip" target="_blank" rel="noopener">转换包下载地址</a></li></ul><a id="more"></a>   <blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在&lt;code&gt;deeplin&lt;/code&gt;的&lt;code&gt;Linux&lt;/code&gt;系统上使用&lt;code&gt;Genymotion&lt;/code&gt;安装程序时，提示&lt;code&gt;Installation error: INSTALL_FAILED_NO_MATCHING_ABIS&lt;/code&gt;，&lt;br&gt;意思是没有匹配的架构。Genymotion模拟器使用的是&lt;code&gt;x86&lt;/code&gt;架构，所以&lt;code&gt;ARM&lt;/code&gt;架构的程序安装不了。&lt;br&gt;解决办法就是给模拟器安装一个&lt;code&gt;ARM&lt;/code&gt;架构的转换包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;打开模拟器，可以正常运行，将下载的转换包拖进模拟器，会提示安装，点击安装。&lt;/li&gt;
&lt;li&gt;安装成功后，打开命令行，输入&lt;code&gt;adb shell /system/etc/houdini_patcher.sh&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;重新打开模拟器，再次运行程序，成功安装。&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/qq_30707799/article/details/68927892&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考地址&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://p6jk8aaz8.bkt.clouddn.com/Genymotion-ARM-Translation.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转换包下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="2018" scheme="https://pingerx.com/tags/2018/"/>
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Linux" scheme="https://pingerx.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Github添加SSH公钥流程</title>
    <link href="https://pingerx.com/2018/03/25/github-tian-jia-ssh-gong-yao-liu-cheng/"/>
    <id>https://pingerx.com/2018/03/25/github-tian-jia-ssh-gong-yao-liu-cheng/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.172Z</updated>
    
    <content type="html"><![CDATA[<p>使用Git操作Github远程仓库时需要登录账号和密码，但是每次操作都需要登录非常麻烦。<br>所幸Github服务器使用了SSH公钥认证，所以只需要在本地生成一份公钥并添加到Github服务器就可以免去重复登录。</p><a id="more"></a>  <h3 id="1-检查本地已有公钥"><a href="#1-检查本地已有公钥" class="headerlink" title="1. 检查本地已有公钥"></a>1. 检查本地已有公钥</h3><ul><li>公钥默认是生成在<code>C:\Users\Administrator\.ssh</code>目录下，检查该目录是否有文件，如果不正确的话可以删除重新生成。</li><li>或者打开<code>Git</code>命令窗口，输入<code>ls -al ~/.ssh</code>会列出.ssh目录的文件。</li></ul><h3 id="2-生成新的SSH公钥"><a href="#2-生成新的SSH公钥" class="headerlink" title="2. 生成新的SSH公钥"></a>2. 生成新的SSH公钥</h3><ul><li><code>git</code>命令行输入<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>，替换成自己在<code>github</code>的邮箱地址，一直确认就会在<code>C:\Users\Administrator\.ssh</code>生成公钥。</li></ul><h3 id="3-添加公钥到代理"><a href="#3-添加公钥到代理" class="headerlink" title="3. 添加公钥到代理"></a>3. 添加公钥到代理</h3><ul><li><code>git</code>命令行输入<code>eval $(ssh-agent -s)</code></li><li><code>git</code>命令行输入<code>ssh-add ~/.ssh/id_rsa</code></li></ul><h3 id="3-复制生成的公钥添加到Github账号"><a href="#3-复制生成的公钥添加到Github账号" class="headerlink" title="3. 复制生成的公钥添加到Github账号"></a>3. 复制生成的公钥添加到Github账号</h3><ul><li><code>git</code>命令行执行<code>cat ~/.ssh/id_rsa.pub</code>可以列出公钥内容，复制。</li><li>或者进入<code>C:\Users\Administrator\.ssh</code>目录，复制<code>id_rsa.pub</code>文件的内容。</li><li>登录Github，在设置里添加公钥即可。</li></ul><h3 id="4-测试是否连接成功"><a href="#4-测试是否连接成功" class="headerlink" title="4. 测试是否连接成功"></a>4. 测试是否连接成功</h3><ul><li><code>git</code>命令行执行<code>ssh -T git@github.com</code>，如果出现<code>Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>就表示成功。</li></ul><h3 id="更多关于Github添加SSH公钥信息"><a href="#更多关于Github添加SSH公钥信息" class="headerlink" title="更多关于Github添加SSH公钥信息"></a>更多关于Github添加SSH公钥信息</h3><ul><li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">Github添加SSH公钥官方教程</a></li><li><a href="https://help.github.com/categories/authenticating-to-github/" target="_blank" rel="noopener">Github添加SSH公钥常见问题</a></li></ul><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Git操作Github远程仓库时需要登录账号和密码，但是每次操作都需要登录非常麻烦。&lt;br&gt;所幸Github服务器使用了SSH公钥认证，所以只需要在本地生成一份公钥并添加到Github服务器就可以免去重复登录。&lt;/p&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="2018" scheme="https://pingerx.com/tags/2018/"/>
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Git" scheme="https://pingerx.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>开发记录之App启动优化</title>
    <link href="https://pingerx.com/2017/12/19/kai-fa-ji-lu-zhi-app-qi-dong-you-hua/"/>
    <id>https://pingerx.com/2017/12/19/kai-fa-ji-lu-zhi-app-qi-dong-you-hua/</id>
    <published>2017-12-18T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.176Z</updated>
    
    <content type="html"><![CDATA[<hr><p>项目重构App的启动，之前的处理是使用SplashActivity作为过渡页，然后将Application中的第三方SDK放到IntentService中加载，<br>启动过程中的一些耗时操作也都去掉了，奈何MainActivity中的业务逻辑还是太过复杂，启动仍然比较漫长。<br>研究了一下<code>淘宝</code>项目的启动处理，总结出一种非常优化的App启动方案。</p><h3 id="传统的启动处理"><a href="#传统的启动处理" class="headerlink" title="传统的启动处理"></a><code>传统的启动处理</code></h3><p>市面上大部分的App启动处理如出一辙，基本都是先进入SplashActivity，然后Handler延时后跳转到MainActivity。</p><a id="more"></a>   <p>这样做的好处是SplashActivity作为过渡页更加轻量，启动到显示界面的时间更短，给用户较好的体验，而且SplashActivity中也可以提前做一些数据处理，减轻MainActivity的压力。但是加入SplashActivity过渡页也有一些缺点，比如要多绘制一个页面，要使用Intent传递数据，不能减轻MainActivity页面的绘制压力和一些数据加载。<br><img src="http://oibrygxgr.bkt.clouddn.com/app_lun1.png" alt="Alt text"></p><p>除此之外，Application的处理也是一个很重要的点，因为App启动是先走Application的onCreate方法的，如果onCreate中加载SDK的时间过于漫长，就会导致App启动后显示一段时间白屏页才会进入SplashActivity，当然也可以使用windowBackGround属性避免白屏，但是时间长了总是会影响用户体验的。所以Application中一般都是采用IntentService来加载SDK的。</p><p>为了解决App启动慢和SplashActivity过渡启动的缺点，个人去研究了一下淘宝的启动，发现第一次启动耗时大概3秒，然后退出去，再进入时就不会显示Splash，直接进入主页读取缓存显示页面。我猜测淘宝的启动肯定是根据应用的进程是否存活，如果存活就直接进入MainActivity，否则显示Splash，而且淘宝的Splash加载很快，MainActivity的加载也很快，所以淘宝应该是采用了Splash绑定在Mainactivity上的方式，即<code>SplashFragment+StubView</code>的方式启动App。</p><h3 id="优化后的Splash"><a href="#优化后的Splash" class="headerlink" title="优化后的Splash"></a><code>优化后的Splash</code></h3><p>传统的App启动方式不足以满足现在用户的体验，用户需要的是加载更快，性能更优的体验，所以这里采用SplashFragment+StubView的方式去实现App的快速启动。<br><img src="http://oibrygxgr.bkt.clouddn.com/app_lun2.png" alt="Alt text"></p><p>跟传统启动方式最大的不同是，优化后的启动会直接进入MainActivity，然后在MainActivity控制Splash的显示隐藏，这样在填充Splash的时候还以为直接加载MainActivity的数据，当窗体填充完毕之后，就可以绘制MainActivity的布局，然后移除Splash，展示页面，这种方式很好的体现了异步的操作，使得填充和加载分离，启动的速度更快。</p><p>既然知道了这种实现方式，那具体代码是如何编写的呢，接下来看一下如何实现。</p><h4 id="1-填充SplashFragment"><a href="#1-填充SplashFragment" class="headerlink" title="1. 填充SplashFragment"></a>1. 填充SplashFragment</h4><p>在MainActivity的onCreate方法中，首先，需要做的就是填充Splash并显示，显示的内容就可以在SplashFragment中编辑。</p><pre><code>    log.d(TAG, &quot;==========填充SplashFragment==========&quot;);    // 1.初始化SplashFragment，填充Splash    final SplashFragment splashFragment = new SplashFragment();    getFragmentManager().beginTransaction().replace(R.id.container,splashFragment).commitAllowingStateLoss();</code></pre><h4 id="2-窗体部署完毕，填充主页布局"><a href="#2-窗体部署完毕，填充主页布局" class="headerlink" title="2. 窗体部署完毕，填充主页布局"></a>2. 窗体部署完毕，填充主页布局</h4><p>当整个页面最底层DecorView填充完毕之后，就可以开始去填充MainActivity的布局了，并且使用Handler发送延时消息，2秒后移除Splash。当然移除Splash也可以直接在数据加载完毕显示页面之前移除掉。</p><pre><code>    getWindow().getDecorView().post(new Runnable() {        @Override        public void run() {            // 填充布局            viewStub.inflate();            // 初始化布局            initView();            // 2秒后移除Splash            mHandler.postDelayed(new DelayRunnable(MainActivity.this, splashFragment), 2000);        }    });</code></pre><h3 id="3-加载MainActivity数据"><a href="#3-加载MainActivity数据" class="headerlink" title="3. 加载MainActivity数据"></a>3. 加载MainActivity数据</h3><p>其实加载数据会在第二步之前执行，因为第二步是异步操作，并且加载数据是耗时操作，所以需要更早执行，不要放在第二步里去执行，这里在测试的时候有可能数据先加载完毕，布局才绘制完，调用控件就会有空指针问题，但是实际开发中肯定不会出现这种情况的，MainActivity中的数据加载肯定很耗时。</p><h3 id="Application的优化"><a href="#Application的优化" class="headerlink" title="Application的优化"></a><code>Application的优化</code></h3><p>Application是应用的核心枢纽，应用启动时会先走Application的onCreate方法去初始化一些全局数据，比如SDK等等。但是当全局数据很多时，App的启动就会变得缓慢，因为初始化是同步加载的，所以要想加快启动，就需要将延时操作放到后台去处理。</p><p>Android里有一个Service，正好可以做延时处理的操作，这个Service就是IntentService。关于IntentService，不了解的看这里。<br><a href="http://www.jianshu.com/p/332b6daf91f0" target="_blank" rel="noopener">IntentService 示例与详解</a><br><a href="https://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="noopener">IntentService文档</a></p><p>接下来，看一下如何实现。</p><ul><li><p>自定义InitializeService继承IntentService，实现构造和方法onHandleIntent</p></li><li><p>在Application的onCreate方法中启动初始化服务</p></li></ul><pre><code>     // 启动服务去做耗时操作     InitializeService.start(this);     public static void start(Context context) {           Intent intent = new Intent(context, InitializeService.class);            intent.setAction(ACTION_APP_LAUNCHER);            context.startService(intent);     }</code></pre><ul><li>在onHandleIntent方法中判断Intent，然后去初始化SDK</li></ul><pre><code>     @Override      protected void onHandleIntent(@Nullable Intent intent) {          if (intent != null) {                final String action = intent.getAction();                if (ACTION_APP_LAUNCHER.equals(action)) {                    performInit();                }          }      }        /**         * 启动初始化耗时操作         */        private void performInit() {            // 模拟延时加载            SystemClock.sleep(2000);            Log.d(TAG, &quot;==========初始化第三方SDK结束==========&quot;);         }</code></pre><p><code>注意：</code></p><ul><li>在清单文件中配置Application和Service</li><li>并不是所有的SDK都能放到Service中去初始化的，在MainActivity中用到的还是需要提前初始化</li></ul><p><a href="https://github.com/PingerOne/android_develop_sample.git" target="_blank" rel="noopener">Demo下载地址</a></p><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;项目重构App的启动，之前的处理是使用SplashActivity作为过渡页，然后将Application中的第三方SDK放到IntentService中加载，&lt;br&gt;启动过程中的一些耗时操作也都去掉了，奈何MainActivity中的业务逻辑还是太过复杂，启动仍然比较漫长。&lt;br&gt;研究了一下&lt;code&gt;淘宝&lt;/code&gt;项目的启动处理，总结出一种非常优化的App启动方案。&lt;/p&gt;
&lt;h3 id=&quot;传统的启动处理&quot;&gt;&lt;a href=&quot;#传统的启动处理&quot; class=&quot;headerlink&quot; title=&quot;传统的启动处理&quot;&gt;&lt;/a&gt;&lt;code&gt;传统的启动处理&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;市面上大部分的App启动处理如出一辙，基本都是先进入SplashActivity，然后Handler延时后跳转到MainActivity。&lt;/p&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="https://pingerx.com/tags/Android/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>过客，一个人的朝圣</title>
    <link href="https://pingerx.com/2017/09/14/guo-ke/"/>
    <id>https://pingerx.com/2017/09/14/guo-ke/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.179Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=471797594&auto=0&height=66"></iframe>---<p>没有谁能够想到 你会出现我身旁<br>也许是命运开的玩笑 不敢太靠近你的身边<br>怕你会嫌烦 只有一个人默默孤单<br>是什么让我们遇见的 是什么让距离更近了<br>不奢求你多好 给我多一点微笑</p><a id="more"></a>   <p>你只是一个过客 从我的世界路过<br>我不敢太多不舍 怕你看出我难过<br>也许我想的太多 却不能给你什么<br>努力把伤心变少 笑容变多就好了<br>我只是个陪伴者 陪着你伤心难过<br>寂寞它每天数着 你那么多的失落<br>你想要什么你说 只要我现在有的<br>我们之间的点点滴滴 我一直都记得</p><p>不敢太靠近你的身边 怕你会嫌烦<br>只有 一个人默默孤单<br>是什么让我们遇见的 是什么让距离更近了<br>不奢求你多好 再多给我一点微笑</p><p>我只是一个过客 从你的世界路过<br>我不敢太多不舍 怕你看出我难过<br>我想的太多 却不能给你什么<br>努力把伤心变少 笑容变多就好了<br>我只想每天陪着 陪着你伤心难过<br>寂寞它每天数着 你那么多的失落<br>你想要什么你说 只要我现在有的<br>我们之间的点点滴滴 我一直都记得</p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=471797594&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
---

&lt;p&gt;没有谁能够想到 你会出现我身旁&lt;br&gt;也许是命运开的玩笑 不敢太靠近你的身边&lt;br&gt;怕你会嫌烦 只有一个人默默孤单&lt;br&gt;是什么让我们遇见的 是什么让距离更近了&lt;br&gt;不奢求你多好 给我多一点微笑&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://pingerx.com/categories/life/"/>
    
    
      <category term="生活" scheme="https://pingerx.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="旧事" scheme="https://pingerx.com/tags/%E6%97%A7%E4%BA%8B/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>凉城，叙事</title>
    <link href="https://pingerx.com/2017/09/12/liang-cheng-xu-shi/"/>
    <id>https://pingerx.com/2017/09/12/liang-cheng-xu-shi/</id>
    <published>2017-09-11T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.174Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=551347831&auto=0&height=66"></iframe>---<p>站在雨中目送你穿过那渡口<br>离岸的船舶漂走远去的轮廓<br>惆怅惹灯火 往事渐落寞<br>烟波起落 被遗忘的是我</p><a id="more"></a>   <p>十里洋场的繁华依旧<br>这幅光景也掩不去我的难过<br>曾陪我看过 老街的烟火<br>缘分蹉跎 花难结果</p><p>当海风吹凉霓虹 回首你无影踪<br>转眼旧盟已成空 赏夜色千家朦胧<br>风花雪月如梦 提醒我也曾爱过<br>任眼泪划伤面容 飘浮在情海中<br>横渡春夏与秋冬 这城市车水马龙<br>我心事无人懂 回忆让人更心痛</p><p>凉城中 不夜城的邂逅未断过<br>而你的温柔却早已年久失修<br>弄堂诉离愁 苔痕如伤口<br>我在那头 等你很久</p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=551347831&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
---

&lt;p&gt;站在雨中目送你穿过那渡口&lt;br&gt;离岸的船舶漂走远去的轮廓&lt;br&gt;惆怅惹灯火 往事渐落寞&lt;br&gt;烟波起落 被遗忘的是我&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://pingerx.com/categories/life/"/>
    
    
      <category term="生活" scheme="https://pingerx.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="旧事" scheme="https://pingerx.com/tags/%E6%97%A7%E4%BA%8B/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>开发记录之沉浸式状态栏最简单实现</title>
    <link href="https://pingerx.com/2017/08/17/kai-fa-ji-lu-zhi-chen-jin-shi-zhuang-tai-lan-zui-jian-dan-shi-xian/"/>
    <id>https://pingerx.com/2017/08/17/kai-fa-ji-lu-zhi-chen-jin-shi-zhuang-tai-lan-zui-jian-dan-shi-xian/</id>
    <published>2017-08-16T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.177Z</updated>
    
    <content type="html"><![CDATA[<hr><p>网上有很多对于沉浸式状态栏的讲解，也有很多实现沉浸式状态栏的方法。<br>具体的原理可以参考几篇分析的比较不错的文章：<br><a href="http://www.jianshu.com/p/f3683e27fd94" target="_blank" rel="noopener">Android沉浸式UI实现及原理</a><br><a href="http://www.jianshu.com/p/34a8b40b9308" target="_blank" rel="noopener">Android 系统状态栏沉浸式/透明化完整解决方案</a></p><p>这里将两种实现起来比较简单的方式贴出来，可以直接拿去使用。</p><a id="more"></a>  <h3 id="通过代码进行设置"><a href="#通过代码进行设置" class="headerlink" title="通过代码进行设置"></a>通过代码进行设置</h3><ul><li>在想要实现透明状态栏的Activity里，或者BaseActivity里的setContentView()方法后调用如下代码</li></ul><!-- more -->  <pre><code>  // 设置状态栏，仅支持到4.4以上版本的Android系统，即API19  public static void initStatus(Activity activity) {      if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {          activity.getWindow().setFlags(                  WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,                  WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);      }  }</code></pre><ul><li>以上代码会把整个状态栏去掉，所以需要在布局文件里的ToolBar设置paddingTop的属性，statusBarSize=25dp</li></ul><pre><code>  android:paddingTop=&quot;@dimen/statusBarSize&quot;</code></pre><ul><li>由于透明状态栏是Google在Android 4.4之后才支持的，所以需要根据不同的版本设置statusBarSize的大小，新建values-v19文件夹，将dimen文件的statusBarSize改成0p就好了</li></ul><h3 id="通过配置主题进行设置"><a href="#通过配置主题进行设置" class="headerlink" title="通过配置主题进行设置"></a>通过配置主题进行设置</h3><ul><li>在values文件中设置AppTheme</li></ul><pre><code>  &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;     &lt;!-- Customize your theme here. --&gt;     &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;     &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;     &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;     &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;  &lt;/style&gt;</code></pre><ul><li>在res下新建一个values-v19文件夹，然后新建values.xml文件，设置AppTheme，这是兼容到4.4版本的写法</li></ul><pre><code>  &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;      &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;      &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;      &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;      &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;      &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;      &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;  &lt;/style&gt;</code></pre><ul><li>在res下新建一个values-v21文件夹，然后新建values.xml文件，设置AppTheme，兼容5.0的写法</li></ul><pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;     &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;     &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;     &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;     &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;     &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;false&lt;/item&gt;     &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;     &lt;!--Android 5.x开始需要把颜色设置透明，否则导航栏会呈现系统默认的浅灰色--&gt;     &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt;</code></pre><ul><li>同理，以上代码也会把整个状态栏去掉，所以还需要在布局文件里的根容器下设置如下代码，然后在values-v19文件夹中将dimen文件的statusBarSize改成0p就好了</li></ul><pre><code>   android:paddingTop=&quot;@dimen/statusBarSize&quot;</code></pre><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;网上有很多对于沉浸式状态栏的讲解，也有很多实现沉浸式状态栏的方法。&lt;br&gt;具体的原理可以参考几篇分析的比较不错的文章：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/f3683e27fd94&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android沉浸式UI实现及原理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/34a8b40b9308&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 系统状态栏沉浸式/透明化完整解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里将两种实现起来比较简单的方式贴出来，可以直接拿去使用。&lt;/p&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="https://pingerx.com/tags/Android/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>开发记录之Android重力感应横竖屏</title>
    <link href="https://pingerx.com/2017/08/13/kai-fa-ji-lu-zhi-android-chong-li-gan-ying-heng-shu-ping/"/>
    <id>https://pingerx.com/2017/08/13/kai-fa-ji-lu-zhi-android-chong-li-gan-ying-heng-shu-ping/</id>
    <published>2017-08-12T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.175Z</updated>
    
    <content type="html"><![CDATA[<hr><p>开发时遇到播放视频要用重力感应来横竖屏，并且要有按钮点击横竖屏，查了很多资料，并参考了网上一些实现思路，终于把重力感应横竖屏完整实现，现封装成工具类，可以直接使用。</p><h3 id="一、实现原理"><a href="#一、实现原理" class="headerlink" title="一、实现原理"></a>一、实现原理</h3><blockquote><p>既然是重力感应横竖屏，那就肯定要有重力感应，重力感应属于传感器的一类，所以需要用到重力感应传感器，不清楚的同学可以google一下。由于视频播放或者直播页面一直都需要重力感应，所以还需要绑定播放页面的生命周期来注册重力感应和注销重力感应。这样当注册重力感应后，就可以获取当前屏幕的朝向角度，根据这些角度来判断哪个范围需要横竖屏。</p></blockquote><a id="more"></a>   <h3 id="二、实现逻辑"><a href="#二、实现逻辑" class="headerlink" title="二、实现逻辑"></a>二、实现逻辑</h3><h4 id="2-1-打造工具类ScreenRotateUtil"><a href="#2-1-打造工具类ScreenRotateUtil" class="headerlink" title="2.1 打造工具类ScreenRotateUtil"></a>2.1 打造工具类ScreenRotateUtil</h4><ul><li><p>由于要绑定生命周期，并且可以点击横竖屏，所以可以做一个工具类，提供start()和stop方法来绑定生命周期，并且暴露一个点击切换横竖屏的方法toggleRotate()就可以。</p></li><li><p>start方法注册监听</p></li></ul><pre><code>    public void start(Activity activity) {        // 接收activity，用于操作屏幕的旋转        mActivity = activity;        // 注册传感器监听        sm.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_UI);    }</code></pre><ul><li>stop()方法注销监听</li></ul><pre><code>    public void stop() {        // 注销监听        sm.unregisterListener(listener);        // 防止内存泄漏        mActivity = null;    }</code></pre><ul><li>toggleRotate()方法，自动切换横竖屏</li></ul><pre><code>    public void toggleRotate() {        /**         * 先判断是否已经开启了重力感应，没开启就直接普通的切换横竖屏         */        if(isEffetSysSetting){            try {                int isRotate = Settings.System.getInt(mActivity.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION);                // 如果用户禁用掉了重力感应就直接切换                if (isRotate == 0) {                    changeOrientation(isLandscape, true);                    return;                }            } catch (Settings.SettingNotFoundException e) {                e.printStackTrace();            }        }        /**         * 如果开启了重力感应就需要修改状态         */        isOpenSensor = false;        isClickFullScreen = true;        if (isChangeOrientation) {            changeOrientation(isLandscape, false);        } else {            isLandscape = !isLandscape;            changeOrientation(isLandscape, false);        }    }</code></pre><h4 id="2-2-重力感应传感器"><a href="#2-2-重力感应传感器" class="headerlink" title="2.2 重力感应传感器"></a>2.2 重力感应传感器</h4><blockquote><p>Android提供了多种传感器，这里只是简单介绍一下重力感应传感器，想了解更多请<a href="http://blog.csdn.net/mad1989/article/details/20848181" target="_blank" rel="noopener">传送</a>。</p></blockquote><ul><li>初始化传感器</li></ul><pre><code>    // 这里在构造里初始化重力重力感应    private ScreenRotateUtil(Context context) {        // 获取传感器管理器        sm = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);        // 获取传感器类型        sensor = sm.getDefaultSensor(Sensor.TYPE_GRAVITY);        // 初始化监听器        listener = new OrientationSensorListener(mHandler);    }</code></pre><ul><li><p>start()方法注册监听，stop()方法注销监听</p></li><li><p>看一下监听里非常重要的方法onSensorChanged，当注册了监听后，这个方法会不停的回调用，不停的给Handler发送消息，然后就可以在Handler里修改屏幕的朝向</p></li></ul><pre><code>    public void onSensorChanged(SensorEvent event) {        float[] values = event.values;        int orientation = ORIENTATION_UNKNOWN;        float X = -values[_DATA_X];        float Y = -values[_DATA_Y];        float Z = -values[_DATA_Z];        float magnitude = X * X + Y * Y;        // Don&#39;t trust the angle if the magnitude is small compared to the y        // value        if (magnitude * 4 &gt;= Z * Z) {            // 屏幕旋转时            float OneEightyOverPi = 57.29577957855f;            float angle = (float) Math.atan2(-Y, X) * OneEightyOverPi;            orientation = 90 - Math.round(angle);            // normalize to 0 - 359 range            while (orientation &gt;= 360) {                orientation -= 360;            }            while (orientation &lt; 0) {                orientation += 360;            }        }        /**         * 获取手机系统的重力感应开关设置，这段代码看需求，不要就删除         * screenchange = 1 表示开启，screenchange = 0 表示禁用         * 要是禁用了就直接返回         */        if(isEffetSysSetting){            try {                int isRotate = Settings.System.getInt(mActivity.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION);                // 如果用户禁用掉了重力感应就直接return                if (isRotate == 0) return;            } catch (Settings.SettingNotFoundException e) {                e.printStackTrace();            }        }        // 只有点了按钮时才需要根据当前的状态来更新状态        if (isClickFullScreen) {            if (isLandscape &amp;&amp; screenIsPortrait(orientation)) {           // 之前是横屏，并且当前是竖屏的状态                Log.d(TAG, &quot;onSensorChanged: 横屏 ----&gt; 竖屏&quot;);                updateState(false, false, true, true);            } else if (!isLandscape &amp;&amp; screenIsLandscape(orientation)) {  // 之前是竖屏，并且当前是横屏的状态                Log.d(TAG, &quot;onSensorChanged: 竖屏 ----&gt; 横屏&quot;);                updateState(true, false, true, true);            } else if (isLandscape &amp;&amp; screenIsLandscape(orientation)) {    // 之前是横屏，现在还是横屏的状态                Log.d(TAG, &quot;onSensorChanged: 横屏 ----&gt; 横屏&quot;);                isChangeOrientation = false;            } else if (!isLandscape &amp;&amp; screenIsPortrait(orientation)) {  // 之前是竖屏，现在还是竖屏的状态                Log.d(TAG, &quot;onSensorChanged: 竖屏 ----&gt; 竖屏&quot;);                isChangeOrientation = false;            }        }        // 判断是否要进行中断信息传递        if (!isOpenSensor) {            return;        }        if (rotateHandler != null) {            rotateHandler.obtainMessage(888, orientation, 0).sendToTarget();        }    }</code></pre><h3 id="2-3-横竖屏处理"><a href="#2-3-横竖屏处理" class="headerlink" title="2.3 横竖屏处理"></a>2.3 横竖屏处理</h3><ul><li>这里的横竖屏是去根据当前手机的朝向即orientation的角度进行判断，然后调用mActivity.setRequestedOrientation()方法设置横竖屏，这里进行了360°的判断，实现了四个方向的横竖屏。</li></ul><pre><code>     if (msg.what == 888) {        int orientation = msg.arg1;        /**         * 根据手机屏幕的朝向角度，来设置内容的横竖屏，并且记录状态         */        if (orientation &gt; 45 &amp;&amp; orientation &lt; 135) {            mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);            isLandscape = true;        } else if (orientation &gt; 135 &amp;&amp; orientation &lt; 225) {            mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);            isLandscape = false;        } else if (orientation &gt; 225 &amp;&amp; orientation &lt; 315) {            mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);            isLandscape = true;        } else if ((orientation &gt; 315 &amp;&amp; orientation &lt; 360) || (orientation &gt; 0 &amp;&amp; orientation &lt; 45)) {            mActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);            isLandscape = false;        }    }</code></pre><h3 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h3><ol><li>Activity的onResume()方法调用start()方法进行注册监听</li><li>Activity的onPause()方法调用stop()方法注销监听</li><li>点击全屏按钮时调用toggleRotate()自动切换横竖屏</li><li>如果需要手机系统的横竖屏按钮生效则调用setEffetSysSetting(true)</li></ol><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>关于重力感应横竖屏其实并不是很难，根据实际的需求去做，一步一步考虑逻辑。这个工具类也基本上是没用什么bug，也可以直接拿去用。如果对你有用可以到我的<a href="https://github.com/PingerOne/ScreenRotation" target="_blank" rel="noopener">Github</a>给个star哦，有什么问题欢迎issues哦。</p><p><a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">我的主页</a><br><a href="https://github.com/PingerOne/ScreenRotation" target="_blank" rel="noopener">Demo下载</a></p><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;开发时遇到播放视频要用重力感应来横竖屏，并且要有按钮点击横竖屏，查了很多资料，并参考了网上一些实现思路，终于把重力感应横竖屏完整实现，现封装成工具类，可以直接使用。&lt;/p&gt;
&lt;h3 id=&quot;一、实现原理&quot;&gt;&lt;a href=&quot;#一、实现原理&quot; class=&quot;headerlink&quot; title=&quot;一、实现原理&quot;&gt;&lt;/a&gt;一、实现原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;既然是重力感应横竖屏，那就肯定要有重力感应，重力感应属于传感器的一类，所以需要用到重力感应传感器，不清楚的同学可以google一下。由于视频播放或者直播页面一直都需要重力感应，所以还需要绑定播放页面的生命周期来注册重力感应和注销重力感应。这样当注册重力感应后，就可以获取当前屏幕的朝向角度，根据这些角度来判断哪个范围需要横竖屏。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="https://pingerx.com/tags/Android/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>开发记录之Activity的转场动画实现</title>
    <link href="https://pingerx.com/2017/06/22/kai-fa-ji-lu-zhi-activity-de-zhuan-chang-dong-hua-shi-xian/"/>
    <id>https://pingerx.com/2017/06/22/kai-fa-ji-lu-zhi-activity-de-zhuan-chang-dong-hua-shi-xian/</id>
    <published>2017-06-21T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.175Z</updated>
    
    <content type="html"><![CDATA[<hr><p>关于Google提供的动画框架，请上传送门，<a href="http://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&mid=2651940687&idx=1&sn=843fcc9cf508751ec2aab7fe059e9436&chksm=84fd75abb38afcbd3b814127a3401d260e8700240289a44ac6156c1daf0a93f1b4e7e0a20e49&scene=0#rd" target="_blank" rel="noopener">Android Transition Framework详解—超炫的动画框架</a></p><p>其中对于Activity的跳转有了很不错的讲解，所以具体请查看动画框架，这里只是简单的讲一下三种跳转方式的实现和应用，<br>实际开发中用的比较多的还是通过主题配置的方式，可以进行全局使用，个别独特的跳转就需要使用动画框架，不过实现了就特别炫。</p><a id="more"></a>   <h2 id="一、通过Theme进行配置（开发中最常用的方式）"><a href="#一、通过Theme进行配置（开发中最常用的方式）" class="headerlink" title="一、通过Theme进行配置（开发中最常用的方式）"></a>一、通过Theme进行配置（开发中最常用的方式）</h2><h3 id="1、写好跳转动画，采用帧动画的形式"><a href="#1、写好跳转动画，采用帧动画的形式" class="headerlink" title="1、写好跳转动画，采用帧动画的形式"></a>1、写好跳转动画，采用帧动画的形式</h3><ul><li>在anim文件夹下创建xml文件，使用set动画集来配置动画</li><li>slide_left_in.xml(Activity从左侧进入的动画)</li></ul><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;translate      android:duration=&quot;300&quot;      android:fromXDelta=&quot;-100.0%p&quot;      android:toXDelta=&quot;0.0&quot;/&gt;  &lt;/set&gt;</code></pre><ul><li>slide_state.xml(Activity保持不变)</li></ul><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  &lt;translate    android:duration=&quot;300&quot;    android:fromXDelta=&quot;0&quot;    android:toXDelta=&quot;0&quot;/&gt;  &lt;/set&gt;</code></pre><h3 id="2、配置跳转Activity的主题"><a href="#2、配置跳转Activity的主题" class="headerlink" title="2、配置跳转Activity的主题"></a>2、配置跳转Activity的主题</h3><ul><li>首先在清单文件中，找到指定的Activity，并配置其主题</li></ul><pre><code>  &lt;activity       android:name=&quot;.ui.activity.TestActivity&quot;       android:theme=&quot;@style/ActivityTheme&quot;/&gt;</code></pre><ul><li>其次在style.xml文件中进行设置</li></ul><pre><code>  &lt;!--配置单个Activity的跳转动画，可以在AppTheme里配置所有Activity的跳转--&gt;  &lt;style name=&quot;ActivityTheme&quot; parent=&quot;AppTheme&quot;&gt;      &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/activityAnim&lt;/item&gt;  &lt;/style&gt;  &lt;!--配置各种方式的跳转动画--&gt;  &lt;style name=&quot;activityAnim&quot;&gt;      &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/slide_right_in&lt;/item&gt;      &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@anim/slide_state&lt;/item&gt;      &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@anim/slide_state&lt;/item&gt;      &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/slide_right_out&lt;/item&gt;  &lt;/style&gt;  &lt;!--activityOpenEnterAnimation ：activity打开时进入的动画--&gt;  &lt;!--activityOpenExitAnimation  ：activity打开时退出的动画--&gt;  &lt;!--activityCloseEnterAnimation ：activity关闭时进入的动画--&gt;  &lt;!--activityCloseExitAnimation  ：activity关闭时退出的动画--&gt;</code></pre><h2 id="二、overridePendingTransition-方法进行设置"><a href="#二、overridePendingTransition-方法进行设置" class="headerlink" title="二、overridePendingTransition()方法进行设置"></a>二、overridePendingTransition()方法进行设置</h2><ul><li><p>在startActivity()和finish()之后可以调用overridePendingTransition()处理跳转动画，这个方法接收两个参数，一个是新启动的activity进入时的动画，另一个是当前activity消失时的动画。</p></li><li><p>启动</p></li></ul><pre><code>  startActivity(new Intent(this, TestActivity.class));  overridePendingTransition(R.anim.slide_right_in, R.anim.slide_state);</code></pre><ul><li>退出</li></ul><pre><code>  finish();  overridePendingTransition(R.anim.slide_right_out, R.anim.slide_state);</code></pre><h2 id="三、谷歌提供的Activity动画类ActivityOptionsCompat"><a href="#三、谷歌提供的Activity动画类ActivityOptionsCompat" class="headerlink" title="三、谷歌提供的Activity动画类ActivityOptionsCompat"></a>三、谷歌提供的Activity动画类ActivityOptionsCompat</h2><ul><li><p>ActivityOptionsCompat是supportv4中新加的一个类，可以为activity添加各种动画效果，里面的api至少要求4.0，部分要求5.0以上，谷歌为我们封装好了的一些拉伸扩散动画，共享元素动画等等。</p></li><li><p>启动</p></li></ul><pre><code>    ActivityOptionsCompat compat = ActivityOptionsCompat.makeCustomAnimation(_mActivity,R.anim.slide_right_in,R.anim.slide_state);    ActivityCompat.startActivity(_mActivity,new Intent(_mActivity,TestActivity.class),compat.toBundle());</code></pre><ul><li>退出</li></ul><pre><code>    ActivityCompat.finishAfterTransition(this);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用时一般是通过配置Theme的方式，在AppTheme里配置所有Activity的跳转动画，进行统一管理，如果需要对某个Activity进行特殊处理，可以使用overridePendingTransition或者ActivityOptionsCompat进行单独设置。</p><p>动画执行优先级：系统动画 &lt; AppTheme &lt; (overridePendingTransition\ActivityOptionsCompat)。</p><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;关于Google提供的动画框架，请上传送门，&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjgwNDIzNQ==&amp;mid=2651940687&amp;idx=1&amp;sn=843fcc9cf508751ec2aab7fe059e9436&amp;chksm=84fd75abb38afcbd3b814127a3401d260e8700240289a44ac6156c1daf0a93f1b4e7e0a20e49&amp;scene=0#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android Transition Framework详解—超炫的动画框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中对于Activity的跳转有了很不错的讲解，所以具体请查看动画框架，这里只是简单的讲一下三种跳转方式的实现和应用，&lt;br&gt;实际开发中用的比较多的还是通过主题配置的方式，可以进行全局使用，个别独特的跳转就需要使用动画框架，不过实现了就特别炫。&lt;/p&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="https://pingerx.com/tags/Android/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>开发记录之自定义scrollbars样式</title>
    <link href="https://pingerx.com/2017/05/20/kai-fa-ji-lu-zhi-zi-ding-yi-scrollbars-yang-shi/"/>
    <id>https://pingerx.com/2017/05/20/kai-fa-ji-lu-zhi-zi-ding-yi-scrollbars-yang-shi/</id>
    <published>2017-05-19T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.177Z</updated>
    
    <content type="html"><![CDATA[<hr><p>由于项目之前引用了一些很老的系统主题，所以显示的scrollbars样式特别的丑，于是我决定自己去自定义一个好看一点的，实现起来也是蛮简单的。</p><p>scrollbars是View自带的一个属性，所以只需要定义一套，之后所有有scrollbars属性的控件都可以使用，当然也可以定制多套，只需要使用shape属性指定颜色就可以。</p><a id="more"></a>  <h3 id="1，使用shape绘制scrollbar的灰色样式"><a href="#1，使用shape绘制scrollbar的灰色样式" class="headerlink" title="1，使用shape绘制scrollbar的灰色样式"></a>1，使用shape绘制scrollbar的灰色样式</h3><ul><li>scrollbar_vertical_thumb.xml文件如下：</li></ul><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;      android:shape=&quot;rectangle&quot;&gt;      &lt;solid android:color=&quot;#55000000&quot;/&gt;      &lt;corners android:radius=&quot;1dp&quot; /&gt;  &lt;/shape&gt;</code></pre><h3 id="2，在需要使用的控件里调用"><a href="#2，在需要使用的控件里调用" class="headerlink" title="2，在需要使用的控件里调用"></a>2，在需要使用的控件里调用</h3><ul><li>比如ListView的自定义scrollbar写法</li></ul><pre><code>  &lt;ListView      android:id=&quot;@id/list&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;      android:clickable=&quot;true&quot;      android:overScrollMode=&quot;never&quot;      android:scrollbarSize=&quot;@dimen/scroll_bar_size&quot;      android:scrollbarThumbVertical=&quot;@drawable/scrollbar_vertical_thumb&quot;/&gt;</code></pre><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;由于项目之前引用了一些很老的系统主题，所以显示的scrollbars样式特别的丑，于是我决定自己去自定义一个好看一点的，实现起来也是蛮简单的。&lt;/p&gt;
&lt;p&gt;scrollbars是View自带的一个属性，所以只需要定义一套，之后所有有scrollbars属性的控件都可以使用，当然也可以定制多套，只需要使用shape属性指定颜色就可以。&lt;/p&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="https://pingerx.com/tags/Android/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>开发记录之RecyclerView的overScrollMode与scrollbars显示冲突</title>
    <link href="https://pingerx.com/2017/04/28/kai-fa-ji-lu-zhi-recyclerview-de-overscrollmode-yu-scrollbars-xian-shi-chong-tu/"/>
    <id>https://pingerx.com/2017/04/28/kai-fa-ji-lu-zhi-recyclerview-de-overscrollmode-yu-scrollbars-xian-shi-chong-tu/</id>
    <published>2017-04-27T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.176Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在使用RecyclerView时，使用overScrollMode=”never”去掉阴影，之后发现scrollbars不显示了，google后找到了解决方式。</p><h3 id="1、有问题的RecyclerView布局"><a href="#1、有问题的RecyclerView布局" class="headerlink" title="1、有问题的RecyclerView布局"></a>1、有问题的RecyclerView布局</h3><ul><li>RecyclerView布局如下</li></ul><pre><code>  &lt;android.support.v7.widget.RecyclerView      android:id=&quot;@id/list&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;      android:overScrollMode=&quot;never&quot;      android:scrollbars=&quot;vertical&quot;/&gt;</code></pre><a id="more"></a>  <h3 id="2、解决方式"><a href="#2、解决方式" class="headerlink" title="2、解决方式"></a>2、解决方式</h3><ul><li>解决方法很简单，将RecyclerView背景设置成透明就好了</li></ul><pre><code>    android:background=&quot;@android:color/transparent&quot;</code></pre><hr><blockquote><p>欢迎大家访问我的<a href="http://www.jianshu.com/u/64f479a1cef7" target="_blank" rel="noopener">简书</a>，<a href="http://wanit.me/" target="_blank" rel="noopener">博客</a>和<a href="https://github.com/PingerOne" target="_blank" rel="noopener">GitHub</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;在使用RecyclerView时，使用overScrollMode=”never”去掉阴影，之后发现scrollbars不显示了，google后找到了解决方式。&lt;/p&gt;
&lt;h3 id=&quot;1、有问题的RecyclerView布局&quot;&gt;&lt;a href=&quot;#1、有问题的RecyclerView布局&quot; class=&quot;headerlink&quot; title=&quot;1、有问题的RecyclerView布局&quot;&gt;&lt;/a&gt;1、有问题的RecyclerView布局&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RecyclerView布局如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;android.support.v7.widget.RecyclerView
      android:id=&amp;quot;@id/list&amp;quot;
      android:layout_width=&amp;quot;match_parent&amp;quot;
      android:layout_height=&amp;quot;match_parent&amp;quot;
      android:overScrollMode=&amp;quot;never&amp;quot;
      android:scrollbars=&amp;quot;vertical&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="develop" scheme="https://pingerx.com/categories/develop/"/>
    
    
      <category term="开发" scheme="https://pingerx.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Android" scheme="https://pingerx.com/tags/Android/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>忘不掉懵懂的那些年</title>
    <link href="https://pingerx.com/2017/02/26/wang-bu-diao-meng-dong-de-na-xie-nian/"/>
    <id>https://pingerx.com/2017/02/26/wang-bu-diao-meng-dong-de-na-xie-nian/</id>
    <published>2017-02-25T16:00:00.000Z</published>
    <updated>2019-12-13T13:59:39.178Z</updated>
    
    <content type="html"><![CDATA[<p>到现在，两年十二个月十二天，已物事人非。<br>虽然放下，但是永远记得并且遗憾，没能和你走到最后。<br>离开后，我听过的每一首歌，看过的每一个故事，沿路的风景，都会让我想起你。<br>对不起，是我没有勇气拥抱你。<br>多年后，祝福另一座城市的你，幸福快乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;到现在，两年十二个月十二天，已物事人非。&lt;br&gt;虽然放下，但是永远记得并且遗憾，没能和你走到最后。&lt;br&gt;离开后，我听过的每一首歌，看过的每一个故事，沿路的风景，都会让我想起你。&lt;br&gt;对不起，是我没有勇气拥抱你。&lt;br&gt;多年后，祝福另一座城市的你，幸福快乐。&lt;/p&gt;

      
    
    </summary>
    
      <category term="life" scheme="https://pingerx.com/categories/life/"/>
    
    
      <category term="生活" scheme="https://pingerx.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="旧事" scheme="https://pingerx.com/tags/%E6%97%A7%E4%BA%8B/"/>
    
      <category term="2017" scheme="https://pingerx.com/tags/2017/"/>
    
  </entry>
  
</feed>
